<template name="api">
{{#markdown}}

<h1 id="api">Meteor API</h1>

Ваш JavaScript-код может работать в двух средах: на *клиенте* (в браузере) и на
*сервере* (под управлением [Node.js](http://nodejs.org/)). Для каждой функции
в этой документации мы будем указывать, где она доступна: только на клиенте,
только на сервере, или же *Везде*.

<h2 id="core"><span>Meteor Core</span></h2>

{{> api_box isClient}}
{{> api_box isServer}}

{{#note}}
`Meteor.isServer` ограничивает область действия кода, но не предотвращает его
отправку на клиент. Любой конфиденциальный код, который не должен попасть на
клиент (например, код, содержащий пароли или механизмы аутентификации),
необходимо хранить в директории `server`.
{{/note}}


{{> api_box startup}}

На сервере функция выполнится как только закончится процесс запуска сервера.
На клиенте функция выполнится как только будет готов DOM.

Функции вызываются в том же порядке, в котором выполнялись соответствующие
вызовы `Meteor.startup`.

На клиенте сначала выполняются `startup`-функции из пакетов, затем шаблоны
`<body>` из `.html` файлов, а затем код приложения.

    // После запуска сервера, если база данных пуста, заполняем ее начальными
    данными.
    if (Meteor.isServer) {
      Meteor.startup(function () {
        if (Rooms.find().count() === 0) {
          Rooms.insert({name: "Initial room"});
        }
      });
    }

{{> api_box absoluteUrl}}

{{> api_box settings}}

{{> api_box release}}

<h2 id="publishandsubscribe"><span>Публикации и подписки</span></h2>

Эти функции служат для публикации наборов данных сервером и для подписки на
эти данные со стороны клиента.

{{> api_box publish}}

Чтобы опубликовать набор документов, вызовите на сервере `Meteor.publish` с
двумя аргументами: названием набора и *функцией публикации*, которою Meteor
будет вызывать каждый раз при подписке клиента на этот набор.

Функции публикации могут возвращать
[`Collection.Cursor`](#meteor_collection_cursor), в случае чего Meteor
опубликует все документы этого курсора для всех подписанных клиентов. Также вы
можете вернуть массив курсоров и Meteor опубликует их все.

{{#warning}}
Если вы возвращаете массив курсоров, то все они должны быть из разных
коллекций. Это временное ограничение и мы постараемся его убрать в будущих
версиях Meteor.
{{/warning}}

    // сервер: опубликовать коллекцию чатов (Rooms), за исключением секретной
    // информации
    Meteor.publish("rooms", function () {
      return Rooms.find({}, {fields: {secretInfo: 0}});
    });

    // ... и опубликовать секретную информацию для чатов, в которых текущий
    // пользователь является админом. Если клиент подписывается на обе
    // публикации, то данные из них объединятся и записываются в
    // соответстующие документы коллекции Rooms.
    Meteor.publish("adminSecretInfo", function () {
      return Rooms.find({admin: this.userId}, {fields: {secretInfo: 1}});
    });

    // опубликовать зависимые документы, имитируя join-ы
    Meteor.publish("roomAndMessages", function (roomId) {
      check(roomId, String);
      return [
        Rooms.find({_id: roomId}, {fields: {secretInfo: 0}}),
        Messages.find({roomId: roomId})
      ];
    });

Кроме того, функции публикации могут явно контролировать публикуемые
ими документы, вызывая методы [`added`](#publish_added) (чтобы добавить новый
документ в публикуемый набор), [`changed`](#publish_changed) (чтобы изменить 
или удалить какие-либо поля в уже опубликованном документе) и 
[`removed`](#publish_removed) (чтобы удалить документы из опубликованного 
набора). Функции публикации, использующие эти методы, также должны вызвать 
метод [`ready`](#publish_ready), как только первый набор документов будет 
готов. Все эти методы доступны у объекта `this` в вашей функции публикации.

Пример:

    // сервер: публикуем текущий размер коллекции
    Meteor.publish("counts-by-room", function (roomId) {
      var self = this;
      check(roomId, String);
      var count = 0;
      var initializing = true;

      // Функция `observeChanges` завершается только после вызова колбэков
      // `added` для всех текущих документов в коллекции, что в нашем случае
      // приведет к посылке клиентам кучи сообщений `self.changed()`.
      // Чтобы этого избежать мы используем флаг `initializing`.
      var handle = Messages.find({roomId: roomId}).observeChanges({
        added: function (id) {
          count++;
          if (!initializing)
            self.changed("counts", roomId, {count: count});
        },
        removed: function (id) {
          count--;
          self.changed("counts", roomId, {count: count});
        }
        // изменения сообщений нам не важны
      });

      // Вместо этого мы пошлем всего одно сообщение `self.added()` сразу после 
      // того, как завершится вызов `observeChanges`, и информируем о 
      // готовности подписки.
      initializing = false;
      self.added("counts", roomId, {count: count});
      self.ready();

      // Перестаем следить за курсором когда клиент отписывается.
      // Остановка подписки автоматически отсылает клиенту все сообщения об
      // удалении из нее документов.
      self.onStop(function () {
        handle.stop();
      });
    });

    // клиент: объявляем коллекци для хранения количества сообщений в чатах
    Counts = new Meteor.Collection("counts");

    // клиент: подписываемся на информацию о количество сообщений в текущем
    // чате
    Deps.autorun(function () {
      Meteor.subscribe("counts-by-room", Session.get("roomId"));
    });

    // клиент: используем новую коллекцию
    console.log("В текущем чате " +
                Counts.findOne(Session.get("roomId")).count +
                " сообщений.");

{{#warning}}
Meteor покажет предупреждение, если вы вызовите `Meteor.publish` в проекте,
используеющем пакет `autopublish`, но ваша функция публикации все же будет
работать.
{{/warning}}

{{> api_box subscription_userId}}

Это константа, но если состояние пользователя изменится (он
разлогинится или залогинится), функция публикации будет перезапущена с новым
значением.

{{> api_box subscription_added}}
{{> api_box subscription_changed}}
{{> api_box subscription_removed}}
{{> api_box subscription_ready}}

{{> api_box subscription_onStop}}

Если в вашей публикации вы использовали функции [`observe`](#observe) или
[`observeChanges`](#observe_changes) для отслеживания изменений в курсорах, то
это самое подходящее место для прекращения слежки.

{{> api_box subscription_error}}
{{> api_box subscription_stop}}

{{> api_box subscription_connection}}

{{> api_box subscribe}}

Подписка на набор данных означает, что сервер должен отослать эти данные на
клиент. Клиент сохраняет эти данные в локальных [коллекциях
Minimongo](#meteor_collection), названия которых берутся из аргумента
`collection` методов [`added`](#publish_added), [`changed`](#publish_changed), и
[`removed`](#publish_removed) хэндлера публикации. Meteor отложит обработку
данных из публикации до тех пор, пока на клиенте не будут объявлены
[коллекции](#meteor_collection), необходимые для их сохранения.

    // Допустим, "allplayers" публикует данные из серверной коллекции "players".
    // На клиенте можно подписаться на эту публикацию (и даже получить данные
    // из нее) перед объявлением коллекции "players".
    Meteor.subscribe("allplayers");
    ...
    // Клиент откладывает обработку данных до тех пор, пока не
    // объявляется коллекция, необходимая для их сохранения.
    Players = new Meteor.Collection("players");

Документ будет доступен на клиенте, если он находится хотя бы в одной из
опубликованных ему подписок.

Колбэк `onReady` вызывается, как только сервер [завершает
публикацию](#publish_ready). Колбэк `onError` вызывается с ошибкой
[`Meteor.Error`](#meteor_error), если подписаться не удается или же сервер
завершает ее, используя метод `error` хэндлера публикации.

`Meteor.subscribe` возвращает хэндлер подписки, обладающий следующими методами:

<dl class="callbacks">
{{#dtdd "stop()"}}
Отменяет подписку. Обычно это приводит к тому, что сервер информирует клиента
о необходимости удалить все данные этой подписки из его локального кэша.
{{/dtdd}}

{{#dtdd "ready()"}}
Результат будет `true`, если сервер [завершил публикацию для данной
подписки](#publish_ready). Реактивный источник данных.
{{/dtdd}}
</dl>

Если вы вызвали `Meteor.subscribe` из [реактивного контекста](#reactivity),
например, из [`Deps.autorun`](#deps_autorun), то эта подписка будет
автоматически отменена, как только данный контекст инвалидируется или будет
остановлен. Поэтому вызывать метод `stop` при использовании `Deps.autorun`
необязательно. Однако, если при следующем запуске ваша функция подпишется на
тот же набор данных, Meteor это поймет и не будет бессмысленно отписываться и
переподписываться заново. Например:

    Deps.autorun(function () {
      Meteor.subscribe("chat", {room: Session.get("current-room")});
      Meteor.subscribe("privateMessages");
    });

Этот код подписывает вас на сообщения из текущего чата и на ваши личные
сообщения. Когда вы смените активный чат при помощи `Session.set("current-room",
"new-room")`, Meteor подпишется на сообщения из нового чата, отпишется от
предыдущего и останется подписанным на ваши личные сообщения.

Если разные подписки устанавливают разные значения одному и тому же полю
определенного документа, то итоговое значение выбирается из них
произвольным образом.

<h2 id="methods_header"><span>Методы</span></h2>

Методы - это функции, которые могут удаленно вызываться клиентами.

{{> api_box methods}}

Пример:

    Meteor.methods({
      foo: function (arg1, arg2) {
        check(arg1, String);
        check(arg2, [Number]);
        // .. тут что-то делаем ..
        if (вы хотите кинуть ошибку)
          throw new Meteor.Error(404, "Не могу найти свои штаны");
        return "возвращаем что-нибудь";
      },

      bar: function () {
        // .. тут делаем что-то другое ..
        return "baz";
      }
    });

Вызов `methods` на сервере объявляет функции, которые клиенты могут выполнять
удаленно. Они должны либо возвращать значение, поддерживаемое
форматом [EJSON](#ejson), либо кидать исключение. Внутри метода, `this`
ссылается на объект, содержащий следующие свойства:

* `isSimulation`: значение типа `Boolean`. Принимает значение `true`, если
вызывается заглушка метода.
* `unblock`: вызов этой функции разрешает выполнение следующего метода от
того же клиента.
* `userId`: id текущего пользователя.
* `setUserId`: функция, ассоциирующая текущего клиента с каким-либо юзером.
* `connection`: доступно на сервере - [подключение](#meteor_onconnection), по которому был совершен вызов данного метода.

Вызов `methods` на клиенте объявляет *заглушки* для одноименных серверных
методов. Их объявление необязательно, и вы можете этого не делать. В этом
случае, вызов методова полностью идентичен технологии удаленного вызова
процедур, используемой в других системах, и вам придется ждать результатов его
выполнения от сервера.

Если же вы объявите заглушку, то она будет вызвана параллельно с серверным
методом. Возвращаемое ей значение клиентом игнорируется. Заглушки
предназначены для *имитирования* результатов вызова серверного метода, не
дожидаясь ответа от него. Если заглушка кинет исключение, оно будет показано
в консоли.

Вы используете методы постоянно, т.к. все функции для работы с базой данных
([`insert`](#insert), [`update`](#update), [`remove`](#remove)) на самом деле
являются методами. Когда вы используете одну из этих функций на клиенте, вы
вызываете ее заглушку, которая обновляет локульную базу данных, и параллельно
посылаете запрос на изменение этой информации на сервер. После ответа
сервера, Meteor актуализирует локальную базу данных клиента в соотвествии с
реально произошедшими на сервере изменениями.

{{> api_box method_invocation_userId}}

Id пользователя - это произвольная строка. Как правило, это id записи
пользователя в базе данных. Вы можете установить его при помощи функции
`setUserId`. Если же вы используете [систему учетных записей
Meteor](#accounts_api), то он устанавливается автоматически.

{{> api_box method_invocation_setUserId}}

Используйте эту функцию, чтобы сменить залогиненного пользователя для текущего
подключения. Она всего лишь устанавливает значение `userId` для всех
последующих вызовов методов. Передайте `null`, чтобы разлогинить пользователя.

Если вы используете [встроенную систему учетных записей
Meteor](#accounts_api), то устанавливаемое значение должно соответствовать
полю `_id` записи пользователя из коллекции [`Meteor.users`](#meteor_users).

{{> api_box method_invocation_isSimulation}}

{{> api_box method_invocation_unblock}}

Методы от одного и того же клиента запускаются на сервере по очереди,
т.е. N+1-ый метод не запустится до тех пор, пока не завершится N-ый. Однако,
вы можете это изменить, вызвав `this.unblock` - это запустит N+1-ый метод в
новом волокне.

{{> api_box method_invocation_connection}}

{{> api_box error}}

Если вы хотите вернуть ошибку из метода, кидайте исключение. В методах можно
кидать любые виды исключений, но на клиент отсылаются только исключения типа
`Meteor.Error`. Если метод кидает любой другой тип исключения, то Meteor
попытается получить из него ошибку нужного типа. Для этого он проверяет
свойство `sanitizedError` объекта исключения и если в нем содержится ошибка
`Meteor.Error`, то она будет послана на клиент. В противном случае клиенту
вернется ошибка `Meteor.Error(500, 'Internal server error')`.

{{> api_box meteor_call}}

Эта функция предназначена для удаленного запуска методов на сервере. Если для
метода объявлена заглушка, она запустится на клиенте параллельно с методом.
(Также обратите внимание на функцию [`Meteor.apply`](#meteor_apply), которая
отличается от `Meteor.call` тем, что аргументы для метода в нее передаются в
виде массива и она предоставляет возможность указать дополнительные опций
для его вызова).

Если последним агрументом указать колбэк-функцию (которая не может быть
аргументом метода, т.к. функции не сериализуются), метод будет вызван
асинхронно: его вызов ничего не вернет и исключений он кидать не будет. Когда
метод выполнится (что может произойти как до, так и после выполнения
`Meteor.call`), будет вызван колбэк, в который будут переданы два аргумента:
`error` and `result`. Если метод кинул исключение, то оно будет передано в
параметре `error`. В противном случае значением `error` будет `undefined`, а
`result` будет содержать результат выполнения метода.

    // Асинхронный вызов
    Meteor.call('foo', 1, 2, function (error, result) { ... } );

Если вы вызвали метод на сервере и не передали колбэк, то он будет
выполняться синхронно и либо вернет значение, возвращенное методом, либо
кинет исключение, возбужденное в методе (возможно, преобразованное в
`Meteor.Error(500, 'Internal server error')`, если исключение произошло
удаленно и его тип был не `Meteor.Error`).

    // Синхронный вызов
    var result = Meteor.call('foo', 1, 2);

На клиенте, если вы не указали колбэк и вы не внутри метода-заглушки, вызов
метода вернет `undefined` и вы никак не сможете получить результат его
выполнения. Так происходит потому, что на клиенте нет поддержки волокон и,
соответсвенно, нет никакой возможности заблокировать выполнение программы на
время работы удаленного метода.

И наконец, если вы, находясь на клиенте внутри метода-заглушки, вызываете
оттуда другой метод, он вызван не будет (т.е. удаленный метод не будет
запущен). Если у этого метода есть заглушка, то она вызовется вместо него и
результат ее выполнения станет результатом выполнения метода. На клиенте
ничто не препятствует синхронному вызову заглушек, поэтому внутри методов
можно использовать синхронную форму вызова `Meteor.call` как на сервере, так
и на клиенте.

Meteor отслеживает все сделанные из методов записи в базу данных как на
сервере, так и на клиенте и не вызывает `asyncCallback` до тех пор, пока все
серверные записи не заменят записи, сделанные заглушками в локальном
кэше. В некоторых случаях между моментом, когда уже доступен результат 
работы метода и моментом, когда актуализированы локальные данные, может
возникнуть некоторая задержка. Например, такое может произойти, если 
какой-либо другой метод, изменив тот же документ, все еще не получил от сервера
его текущее состояние, и локальный кэш может быть неактуальным до тех пор, 
пока он не выполнится. Если же вы хотите обработать результат метода сразу 
после того, как он будет получен от сервера, вы можете указать колбэк 
`onResultReceived` при вызове [`Meteor.apply`](#meteor_apply).

{{> api_box meteor_apply}}

`Meteor.apply` отличается от `Meteor.call` тем, что аргументы для метода в 
нее передаются в виде массива и она предоставляет возможность указать
дополнительные опций для его вызова.

<h2 id="connections"><span>Соединение с сервером</span></h2>

Эти функции отвечают за управление и мониторинг соединения между клиентом и
сервером в Meteor.

{{> api_box status}}

Этот метод возвращает текущий статус соединения между клиентом и сервером.
Возвращаемый объект содержит следующие свойства:

<dl class="objdesc">
{{#dtdd name="connected" type="Boolean"}}
  Принимает значение `true`, если соединение с сервером установлено. Если
  соединения нет, то все изменения данных и вызовы методов будут помещены в
  очередь до тех пор, пока оно не восстановится.
{{/dtdd}}

{{#dtdd name="status" type="String"}}
  Содержит текущий статус соединения. Принимает одно из следующих значений:
  `connected` (соединение установлено и активно), `connecting` (соединение
  разорвано и Meteor пытается его восстановить), `failed` (подключение не
  удалось, например, из-за разных версий DDP на клиенте и сервере), `waiting`
  (подключение не удалось, но скоро Meteor снова попытается его восстановить)
  и `offline` (пользователь разорвал подключение).
{{/dtdd}}

{{#dtdd name="retryCount" type="Number"}}
  Количество попыток восстановления подключения, сделанных клиентом после его
  разрыва. Сбрасывается в 0 после подключения.
{{/dtdd}}

{{#dtdd name="retryTime" type="Number или undefined"}}
  Примерное время следующей попытки восстановления подключения. Чтобы получить
  время, через которое она произойдет, используйте выражение `retryTime - (new
  Date()).getTime()`. Это свойство доступно, только когда `status` имеет
  значение `waiting`.
{{/dtdd}}

{{#dtdd name="reason" type="String или undefined"}}
  Если `status` имеет значение `failed`, это свойство содержит описание
  причины, по которой соединение не удалось.
{{/dtdd}}
</dl>

[Реактивная](#reactivity) природа этого объекта позволяет не использовать
колбэки для информирования вас об изменении статуса подключения. Вы можете
использовать его в [шаблонах](#livehtmltemplates), или же в любом другом [реактивном
контексте](#deps_autorun) чтобы отслеживать его изменения в реальном времени.

{{> api_box reconnect}}

{{> api_box disconnect}}

Используйте этот метод, чтобы разорвать соединение между клиентом и сервером
и остановить обновление данных в реальном времени. До тех пор, пока клиент не
подключится к серверу, он не будет получать обновления в коллекциях, вызовы
методов будут помещены в очередь и горячее обновление кода будет отключено.

Чтобы восстановить соединение и возобновить передачу данных используйте
[Meteor.reconnect](#meteor_reconnect).

Это может быть полезно для экономии энергии на мобильных устройствах, когда
обновление информации в реальном времени не обязательно.


{{> api_box onConnection}}

`onConnection` returns an object with a single method `stop`.  Calling
`stop` unregisters the callback, so that this callback will no longer
be called on new connections.

The callback is called with a single argument, the server-side
`connection` representing the connection from the client.  This object
contains the following fields:

<dl class="objdesc">
{{#dtdd name="id" type="String"}}
A globally unique id for this connection.
{{/dtdd}}

{{#dtdd name="close" type="Function"}}
Close this DDP connection. The client is free to reconnect, but will
receive a different connection with a new `id` if it does.
{{/dtdd}}

{{#dtdd name="onClose" type="Function"}}
Register a callback to be called when the connection is closed. If the
connection is already closed, the callback will be called immediately.
{{/dtdd}}

{{#dtdd name="clientAddress" type="String"}}
  The IP address of the client in dotted form (such as `"127.0.0.1"`).

  If you're running your Meteor server behind a proxy (so that clients
  are connecting to the proxy instead of to your server directly),
  you'll need to set the `HTTP_FORWARDED_COUNT` environment variable
  for the correct IP address to be reported by `clientAddress`.

  Set `HTTP_FORWARDED_COUNT` to an integer representing the number of
  proxies in front of your server.  For example, you'd set it to `"1"`
  when your server was behind one proxy.
{{/dtdd}}

{{#dtdd name="httpHeaders" type="Object"}}
  When the connection came in over an HTTP transport (such as with
  Meteor's default SockJS implementation), this field contains
  whitelisted HTTP headers.

  Cookies are deliberately excluded from the headers as they are a
  security risk for this transport.  For details and alternatives, see
  the [SockJS
  documentation](https://github.com/sockjs/sockjs-node#authorisation).
{{/dtdd}}
</dl>

{{#note}}
Currently when a client reconnects to the server (such as after
temporarily losing its Internet connection), it will get a new
connection each time.  The `onConnection` callbacks will be called
again, and the new connection will have a new connection `id`.

In the future, when client reconnection is fully implemented,
reconnecting from the client will reconnect to the same connection on
the server: the `onConnection` callback won't be called for that
connection again, and the connection will still have the same
connection `id`.
{{/note}}


{{> api_box connect}}

Используйте этот метод для подключения к серверу другого Meteor-приложения.
Это позволит вам подписываться на его публикации и вызывать его удаленые
методы.
`DDP.connect` возвращает объект со следующими свойствами:

* `subscribe` -
  Подписывает на публикации. Смотрите [Meteor.subscribe](#meteor_subscribe).
* `call` -
  Вызывает удаленный метод. Смотрите [Meteor.call](#meteor_call).
* `apply` -
  Вызывает удаленный метод, передавая массив аргументов. Смотрите
  [Meteor.apply](#meteor_apply).
* `methods` -
  Объявляет клиентские заглушки для удаленных методов. Смотрите
  [Meteor.methods](#meteor_methods).
* `status` -
  Возвращает текущий статус соединения. Смотрите
  [Meteor.status](#meteor_status).
* `reconnect` -
  Смотрите [Meteor.reconnect](#meteor_reconnect).
* `disconnect` -
  Смотрите [Meteor.disconnect](#meteor_disconnect).
* `onReconnect` -
  Вы можете присвоить этому свойству функцию, которая будет вызываться в
  качестве первого шага восстановления соединения. Она может вызывать удаленные
  методы, которые будут выполнены перед всеми остальными. Например, это можно
  использовать для восстановления аутентификации для нового соединения.

По умолчанию, клиенты устанавливают соединения с тем сервером, откуда они
были загружены, и вы работаете именно с ним, когда вызываете
`Meteor.subscribe`, `Meteor.status`, `Meteor.call` и `Meteor.apply`.

<h2 id="collections"><span>Коллекции</span></h2>

Meteor хранит данные в *коллекциях*. Для начала, обявите коллекцию, используя
`new Meteor.Collection`.

{{> api_box meteor_collection}}

Вызов этой функции аналогичен объявлению модели во фреймворке, использующем
ORM (Object-Relation Mapper). Он объявляет *коллекцию* (пространство для
хранения данных, или "документов"), которая используется для хранения
определенных типов информации, например данных о пользователях, постов,
оценок, комментариев и всего того, что потребуется вашему приложению.
Каждый документ - это EJSON-объект. Он содержит поле `_id`, уникальное для
каждого документа в коллекции, которое Meteor установит автоматически при его
создании.

    // Общий для клиента и сервера код, объявляющий "живые" (синхронизируемые)
    // Mongo-коллекции.
    Chatrooms = new Meteor.Collection("chatrooms");
    Messages = new Meteor.Collection("messages");

Созданный объект содержит методы для добавления документов в коллекцию
([`insert`](#insert)), их изменения ([`update`](#update)), удаления
([`remove`](#remove)) и поиска ([`find`](#find)). Синтаксис этих методов
совместим с API баз данных Mongo, а доступны они как на сервере, так и
на клиенте:

    // Получить массив моих сообщений
    var myMessages = Messages.find({userId: Session.get('myUserId')}).fetch();

    // Создать новое сообщение
    Messages.insert({text: "Hello, world!"});

    // Пометить мое первое сообщение, как важное
    Messages.update(myMessages[0]._id, {$set: {important: true}});

Если при создании коллекции вы укажете ее имя (параметр `name`), то данная
коллекция будет постоянной &mdash;, т.е. будет храниться на сервере и будет
доступна всем пользователям. Вы сможете получить к ней доступ как с клиента,
так и с сервера, используя один и тот же API.

Вот что происходит, если вы указываете название коллекции:

* Eсли вы не указываете `connection`, на сервере в базе данных Mongo 
создается одноименная коллекция. Когда вы вызываете методы этой коллекции на
сервере, они преобразовываются в соответствующие операции с базой данных 
Mongo (правда, только после проверки указанных вами [правил контроля
доступа](#allow)).

* На клиенте (а также на сервере, если вы укажете `collection`) 
создается экземпляр Minimongo - это частичная реализация Mongo на чистом
JavaScript, хранящая данные в оперативной памяти. Он используется
в качестве локального кэша, хранящего только ту часть базы, которая
необходима данному клиенту. Поиск документов ([`find`](#find)) происходит
только в этом локальном кэше, без обращения к серверу.

* Когда на клиенте вы хотите внести какие-либо изменения в базу данных
(используя методы [`insert`](#insert), [`update`](#update) и
[`remove`](#remove)), то они сразу же вносятся в локальный кэш и
параллельно посылается запрос на их внесение в БД на сервере. Делается это с 
помощью [заглушек](#meteor_methods), т.к. запись в БД реализована в виде 
методов.

{{#note}}
When, on the server, you write to a collection which has a specified
`connection` to another server, it sends the corresponding method to the other
server and receives the changed values back from it over DDP. Unlike on the
client, it does not execute the write locally first.
{{/note}}

Если в качестве названия коллекции вы укажете `null`, тогда будет создана
локальная коллекция. Она ни с чем не синхронизируется - это просто локальное
хранилище документов, позволяющее работать с ними в стиле Mongo (используя
методы [`find`](#find), [`insert`](#insert), [`update`](#update) и
[`remove`](#remove)). Как на клиенте, так и на сервере оно реализовано с
помошью Minimongo.

По-умолчанию Meteor автоматически публикует все документы из коллекции для
всех подключенных клиентов. Чтобы это отключить, удалите из приложения пакет
`autopublish`:

    $ meteor remove autopublish

и вместо этого используйте [`Meteor.publish`](#meteor_publish), чтобы
опубликовать для конкретных пользователей только необходимые им части
коллекции.

    // Создаем коллекцию Posts и добавляем в нее новый документ.
    // Он мгновенно появляется в локальной копии этой коллекции.
    // В серверную базу данных он запишется буквально через долю
    // секунды, а еще через долю секунды он уже будет синхронизирован
    // со всеми клиентами, которые подписаны на содержащий его запрос
    // (смотрите Meteor.subscribe and autopublish)
    Posts = new Meteor.Collection("posts");
    Posts.insert({title: "Hello world", body: "First post"});

    // Изменения доступны мгновенно -- ответ от сервера ждать не надо.
    assert(Posts.find().count() === 1);

    // Создаем локальную коллекцию. Она работает так же, как и любая другая
    // коллекция, за исключением того, что не отсылает изменения на сервер и
    // не получает данные из публикаций.
    Scratchpad = new Meteor.Collection;
    for (var i = 0; i < 10; i++)
      Scratchpad.insert({number: i * 2});
    assert(Scratchpad.find({number: {$lt: 9}}).count() === 5);

Generally, you'll assign `Meteor.Collection` objects in your app to global
variables.  You can only create one `Meteor.Collection` object for each
underlying Mongo collection.

Если вы укажете функцию трансформации (опция `transform`) документов при
создании коллекции, или же при вызове ее некоторых методов, то она будет
использоваться для преобразования документов перед их возвращением из
соответствующих функций, или перед их передачей в колбэки. Это позволяет
расширить возможности при работе с документами (например, обернуть их в
класс и т.п.). Опцию `transform` поддерживают функции `find`, `findOne`,
`allow` и `deny`. Функции трансформации должны возвращать объект и они не 
могут менять значение поля `_id` документа.

    // Создаем класс Animal, конструктор которого принимает документ
    Animal = function (doc) {
      _.extend(this, doc);
    };
    _.extend(Animal.prototype, {
      makeNoise: function () {
        console.log(this.sound);
      }
    });

    // Объявляем коллекцию, которая преобразует свои документы в объекты
    // класса Animal
    Animals = new Meteor.Collection("Animals", {
      transform: function (doc) { return new Animal(doc); }
    });

    // Создаем новый документ, получаем его преобразованную версию в виде
    // объекта класса Animal и вызываем у него метод makeNoise
    Animals.insert({name: "raptor", sound: "roar"});
    Animals.findOne({name: "raptor"}).makeNoise(); // prints "roar"

Функции `transform` реактивно не вызываются, поэтому если вы хотите добавить
в объект динамически изменяющийся атрибут, то сделайте его в виде метода,
вычисляющего свое значение во время вызова, а не в виде свойства, значение
которого вычисляется в момент трансформации.

{{#warning}}
В данном релизе у Minimongo присутствуют некоторые ограничения:

* `$pull` в модификаторах принимает только определенные виды селекторов.
* не поддерживаются `findAndModify`, функции группировки, и map/reduce.

Их поддержка будет рассмотрена в будущих версиях. Полная информация касательно
релиза Minimongo находится в репозитории в файле packages/minimongo/NOTES.
{{/warning}}

{{#warning}}
В данный момент Minimongo не поддерживает индексы. Это сложно назвать
проблемой, т.к. клиенту несвойственно иметь настолько большие объемы данных,
что для них понадобился бы индекс.
{{/warning}}

{{> api_box find}}

Метод `find` возвращает курсор. К базе данных он обращается не сразу, а
предоставляет метод `fetch` для получения всех найденных документов, методы `map` и
`forEach` для последовательной обработки найденных документов и методы
`observe` и `observeChanges` для отслеживания изменений в них.

{{#warning}}
Курсоры не являются снимками запросов, т.е. если база данных изменится между
вызовом `Collection.find` и получением найденных документов при помощи метода
`fetch` курсора (или во время получения документов), то невозможно с
уверенностью сказать, попадут ли эти изменения в результат, или нет.
{{/warning}}

Курсоры - это реактивный источник данных. На клиенте, когда вы, находясь в
реактивном контексте, первый раз получаете документы курсора с помощью 
методов `fetch`, `map` и `forEach`, Meteor устанавливает зависимость между
этим контекстом и полученными данными. Любое изменение коллекции, которое
вызывает изменение документов курсора, ведет к перевыполнению этого 
контекста. Чтобы отключить такое поведение, передайте в метод `find` опцию
`{reactive: false}`.

Note that when `fields` are specified, only changes to the included
fields will trigger callbacks in `observe`, `observeChanges` and
invalidations in reactive computations using this cursor. Careful use
of `fields` allows for more fine-grained reactivity for computations
that don't depend on an entire document.

{{> api_box findone}}

Это эквивалентно вызову `find(selector, options).fetch()[0]` с опцией `limit = 1`.

{{> api_box insert}}

Добавляет документ в коллекцию. Документ - это всего лишь объект, состоящий
из любых EJSON-совместивых данных (массивов, объектов, чисел, строк, значений
`null`, `true` и `false`).

Для переданного в функцию `insert` объекта она генерирует уникальный ID,
добавляет получившийся документ в базу данных и возвращает его ID. Когда
`insert` вызывается на клиенте, документ будет добавлен только в том случае,
если успешно пройдены все разрешающие ([`allow`](#allow)) и запрещающие
([`deny`](#deny)) правила.

На сервере, если вы не укажете колбэк, `insert` заблокирует выполнение кода до
тех пор, пока база данных не подтвердит факт записи, или же не бросит
исключение, если запись не удалась. Если вы укажете колбэк, то, несмотря
на это, `insert` так же отдаст вам ID нового документа. Как только запись
будет произведена (или закончится неудачей), колбэк вызовется с двумя
аргументами: объектом ошибки (`error`) и результатом (`result`). В случае
ошибки, `result` будет `undefined`. В случае успешной записи, `error` будет
`undefined`, а `result` будет содержать ID добавленного документа.

На клиенте, `insert` никогда не блокирует выполнение кода. Если вы не укажете
колбэк и добавление документа на сервере закончится неудачей, то Meteor
выведет в консоль предупреждение. Если вы укажете колбэк, он будет вызван с
двумя аргументами: объектом ошибки (`error`) и результатом (`result`). В случае
ошибки, `result` будет `undefined`. В случае успешной записи, `error` будет
`undefined`, а `result` будет содержать ID добавленного документа.

Пример:

    var groceriesId = Lists.insert({name: "Groceries"});
    Items.insert({list: groceriesId, name: "Watercress"});
    Items.insert({list: groceriesId, name: "Persimmons"});

{{> api_box update}}

Изменяет документы, удовлетворяющие селектору, согласно модификатору
(смотрите [документацию по модификаторам](#modifiers)).

Поведение метода `update` различается в зависимости от того, вызывется ли он
из доверенного, или недоверенного кода. Доверенным кодом является серверный
код и код методов. Недоверенный код - это клиентский код (включая код,
вводимый в консоли браузера).

- Из доверенного кода можно изменять несколько документов за раз, указав
  `true` в качестве значения опции `multi`, а также использовать произвольный
  [Mongo-селектор](#selectors) для поиска изменяемых документов. Правила
  контроля доступа, объявленные при помощи методов [`allow`](#allow) и
  [`deny`](#deny), не проверяются. Если вы не укажите колбэк, `update` вернет
  вам количество измененных документов.

- Из недоверенного кода можно изменять только по одному документу за раз,
  указывая их `_id`. Документ изменяется только после успешной проверки
  всех разрешающих ([`allow`](#allow)) и запрещающих ([`deny`](#deny)) правил.
  Количество измененных документов будет передано в колбэк. Опция `upsert`
  работает только в небезопасном режиме работы приложения.

На сервере, если вы не укажете колбэк, `update` заблокирует выполнение кода до
тех пор, пока база данных не подтвердит факт изменения и метод не вернет
количество измененных документов, или же не бросит исключение, если изменение
не удалось. Если же вы укажете колбэк, `update` завершится немедленно.
Как только изменение будет произведено (или закончится неудачей), колбэк
вызовется с двумя аргументами: объектом ошибки (`error`) и результатом
(`result`). В случае ошибки, `result` будет `undefined`. В случае успешного
изменения, `error` будет `undefined`, а `result` будет содержать количество
измененных документов.

На клиенте, `update` никогда не блокирует выполнение кода. Если вы не укажете
колбэк и изменение документа на сервере закончится неудачей, то Meteor
выведет в консоль предупреждение. Если же вы укажете колбэк, то он будет
вызван с двумя аргументами: объектом ошибки (`error`) и результатом
(`result`). В случае ошибки, `result` будет `undefined`. В случае успешного
изменения, `error` будет `undefined`, а `result` будет содержать количество
измененных документов.

Пример кода на клиенте:

    // Даем 5 очков текущему игроку при нажатии соответствующей кнопки на
    // панеле админа. Количество очков незамедлительно обновится у всех
    // пользователей.
    Template.adminDashboard.events({
      'click .givePoints': function () {
        Players.update(Session.get("currentPlayer"), {$inc: {score: 5}});
      }
    });

Пример кода на сервере:

    // Даем значок победителя каждому пользователю, у которого более 10 очков.
    // Если они залогинены и в данный момент на экране видят список своих
    // значков, то он будет автоматически обновлен прямо у них на глазах.
    Meteor.methods({
      declareWinners: function () {
        Players.update({score: {$gt: 10}},
                       {$addToSet: {badges: "Winner"}},
                       {multi: true});
      }
    });

Вы можете использовать `update` в режиме `upsert`, установив значение `true`
одноименной опции. Также вы можете воспользоваться методом
[`upsert`](#upsert), который дополнительно возвращает `_id` добавленного
документа (если таковой имеется).

{{> api_box upsert}}

Согласно модификатору, изменяет документы, удовлетворяющие селектору, или же,
добавляет новый документ, если ни один из них не был изменен. Использование
метода `upsert` равносильно использованию `update` с опцией `upsert`, за
исключением того, что `upsert` возвращает объект, содержищий свойства
`numberAffected` и `insertedId` (`update` возвращает лишь количество
измененных документов).

{{> api_box remove}}

Находит все документы, удовлетворяющие селектору, и удаляет их из коллекции.

Поведение метода `remove` различается в зависимости от того, вызывется ли он
из доверенного, или недоверенного кода. Доверенным кодом является серверный
код и код методов. Недоверенный код - это клиентский код (включая код,
вводимый в консоли браузера).

- Из доверенного кода можно удалять несколько документов за раз, указав
  `true` в качестве значения опции `multi`, а также использовать произвольный
  [Mongo-селектор](#selectors) для поиска удаляемых документов. Правила
  контроля доступа, объявленные при помощи методов [`allow`](#allow) и
  [`deny`](#deny), не проверяются. Если вы не укажите колбэк, `remove` вернет
  вам количество удаленных документов.

  В целях безопасности, если селектор не указан (или он `undefined`), то ни
  один документ удален не будет. Если вы действительно хотите удалить из
  коллекции все документы, используйте селектор `{}`.

- Из недоверенного кода можно удалять только по одному документу за раз,
  указывая их `_id`. Документ удаляется только после успешной проверки
  всех разрешающих ([`allow`](#allow)) и запрещающих ([`deny`](#deny)) правил.
  Количество удаленных документов будет передано в колбэк.

На сервере, если вы не укажете колбэк, `remove` заблокирует выполнение кода до
тех пор, пока база данных не подтвердит факт удаления и метод не вернет
количество удаленных документов, или же не бросит исключение, если удаление
не удалось. Если же вы укажете колбэк, `remove` завершится немедленно.
Как только удаление будет произведено (или закончится неудачей), колбэк
вызовется с двумя аргументами: объектом ошибки (`error`) и результатом
(`result`). В случае ошибки, `result` будет `undefined`. В случае успешного
удаления, `error` будет `undefined`, а `result` будет содержать количество
удаленных документов.

На клиенте, `remove` никогда не блокирует выполнение кода. Если вы не укажете
колбэк и удаление документа на сервере закончится неудачей, то Meteor
выведет в консоль предупреждение. Если же вы укажете колбэк, то он будет
вызван с двумя аргументами: объектом ошибки (`error`) и результатом
(`result`). В случае ошибки, `result` будет `undefined`. В случае успешного
удаления, `error` будет `undefined`, а `result` будет содержать количество
удаленных документов.

Пример кода на клиенте:

    // Удаляем сообщение при нажатии соответствующей кнопки.
    Template.chat.events({
      'click .remove': function () {
        Messages.remove(this._id);
      }
    });

Пример кода на сервере:

    // После запуска сервера, очищаем журнал и удаляем всех игроков, у которых
    // карма меньше -2.
    Meteor.startup(function () {
      if (Meteor.isServer) {
        Logs.remove({});
        Players.remove({karma: {$lt: -2}});
      }
    });

{{> api_box allow}}

Когда на клиенте вызываются методы `insert`, `update`, или `remove`, на
сервере проверяются все разрешающие (`allow`) и запрещающие ([`deny`](#deny))
правила и только в случае удачной проверки разрешается запись в БД. Если хотя
бы одно разрешающее правило разрешает запись, и ни одно запрещающее правило
ее не запрещает, то запись разрешется.

Эти проверки проводятся только в случае прямой записи в базу данных c
клиента, т.е., например, при вызове `update` из обработчика события.
Серверный код является доверенным и правилами не проверяется. Это также
распространияется и на вызов удаленных методов при помощи `Meteor.call` &mdash;
они должны сами проверять права доступа, а не полагаться на `allow` и `deny`.

Вы можете вызывать `allow` сколько угодно раз, используя любую комбинацию
функций `insert`, `update` и `remove`. Функции должны возвращать `true`, если
операция может быть разрешена. В противном случае они должны возвращать
`false`, или же не возвращать ничего (`undefined`). В этом случае Meteor
продолжит проверку, используя остальные разрешающие правила.

Список возможных функций:

<dl class="callbacks">
{{#dtdd "insert(userId, doc)"}}
Пользователь `userId` хочет добавить документ `doc` в коллекцию.
Верните `true`, чтобы разрешить добавление.
{{/dtdd}}

{{#dtdd "update(userId, doc, fieldNames, modifier)"}}

Пользователь `userId` хочет изменить документ `doc` (`doc` - это текущая
версия документа из БД, без проверяемого изменения). Верните `true`, чтобы
разрешить это изменение.

`fieldNames` - это массив изменяемых полей верхнего уровня документа `doc`,
например `['name',`&nbsp;`'score']`.

`modifier` - это необработанный
Mongo-модификатор, который хочет применить клиент, например `{$set:
{'name.first': "Alice"}, $inc: {score: 1}}`.

Разрешены только Mongo-модификаторы (операции, вроде `$set` и `$push`).
Если пользователь вместо этого попытается заменить целый документ, то такое
изменение будет отклонено без проверки разрешающих правил.

{{/dtdd}}

{{#dtdd "remove(userId, doc)"}}

Пользователь `userId` хочет удалить документ `doc` из коллекции.
Верните `true`, чтобы разрешить удаление.

{{/dtdd}}

</dl>
Когда Meteor вызывает `update` или `remove`, он по-умолчанию получает из БД
весь документ `doc`. Если же документ большой, то, возможно, вы захотите
получить только те его поля, которые используются в вашей функции. Этого
можно добиться, указав список необходимых полей в качестве значения опции
`fetch`.

Пример:

    // Создаем коллекцию, в которой пользователи могут изменять только
    // собственные документы. Владелец документа указывается в его поле
    // 'owner'. Владельцем документа считается его создатель и сменить его
    // нельзя. Удалить документ может только его владелец. Документу можно
    // устанавливать атрибут 'locked', предотвращающий его случайное удаление.

    Posts = new Meteor.Collection("posts");

    Posts.allow({
      insert: function (userId, doc) {
        // пользователь должен быть залогинен и должен быть владельцем этого
        // документа
        return (userId && doc.owner === userId);
      },
      update: function (userId, doc, fields, modifier) {
        // пользователь может изменять только собственные документы
        return doc.owner === userId;
      },
      remove: function (userId, doc) {
        // пользователь может удалять только собственные документы
        return doc.owner === userId;
      },
      fetch: ['owner']
    });

    Posts.deny({
      update: function (userId, docs, fields, modifier) {
        // нельзя менять владельцев
        return _.contains(fields, 'owner');
      },
      remove: function (userId, doc) {
        // нельзя удалять защищенные документы
        return doc.locked;
      },
      fetch: ['locked'] // не нужно получать из БД поле 'owner'
    });

Если вы не объявите для коллекции ни одного разрешающего правила, то все
записи в эту коллекцию с клиента будут запрещены и запись будет доступна
только с сервера. В этом случае все возможные записи в БД с клиента вам
необходимо будет осуществлять посредством вызова удаленных методов, а не
используя напрямую функции `insert`, `update` и `remove`.

Для быстрого прототипирования новых приложений, Meteor поддерживает так
называемый "небезопасный" режим работы. В этом режиме, если вы не объявили
для коллекции ни одного разрешающего или запрещающего правила, то все
пользователи будут иметь к ней полный доступ на запись с клиента. Это
единственная особенность небезопасного режима. Если же вы объявите для
коллекции хотя бы одно правило, даже пустое (например, `Posts.allow({})`), то
проверка правил для нее будет включена. __По-умолчанию все новые проекты на
Meteor работают в небезопасном режиме.__ Чтобы его отключить, выполните
команду `$ meteor remove insecure`.

{{> api_box deny}}

Этот метод работает так же, как и [`allow`](#allow), только он позволяет вам
указать, какие изменения абсолютно точно будут запрещены, даже если они
удовлетворяют какому-то разрешающему правилу.

Когда клиент хочет изменить коллекцию, Meteor сначала проверяет запрещающие
правила. Если ни одно из них не вернуло `true`, он проверяет разрешающие
правила. Meteor разрешает изменение только в том случае, если ни одно
запрещающее правило не вернуло `true` и хотя бы одно разрешающее вернуло
`true`.

<h2 id="meteor_collection_cursor"><span>Курсоры</span></h2>

Курсор создается при помощи метода [`find`](#find). Для получения документов 
из курсора используйте методы [`forEach`](#foreach), [`map`](#map), или
[`fetch`](#fetch).

{{> api_box cursor_foreach}}

Интерфейс этого метода совместим с [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).

Если `forEach` вызывается в реактивном контексте, то он регистрирует 
зависимости между этим контекстом и документами курсора.

Пример:

    // Выводим заголовки пяти самых популярных постов
    var topPosts = Posts.find({}, {sort: {score: -1}, limit: 5});
    var count = 0;
    topPosts.forEach(function (post) {
      console.log("Title of post " + count + ": " + post.title);
      count += 1;
    });

{{> api_box cursor_map}}

Интерфейс этого метода совместим с [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).

Если `map` вызывается в реактивном контексте, то он регистрирует
зависимости между этим контекстом и документами курсора.

<!-- The following is not yet implemented, but users shouldn't assume
     sequential execution anyway because that will break. -->
TODO: On the server, if `callback` yields, other calls to `callback` may occur while
the first call is waiting. If strict sequential execution is necessary, use
`forEach` instead.

{{> api_box cursor_fetch}}

Если `fetch` вызывается в реактивном контексте, то он регистрирует
зависимости между этим контекстом и документами курсора.

{{> api_box cursor_count}}

В отличии от других методов, `count` регистрирует зависимость реактивного
контекста только от количества документов в курсоре. Это означает, что контекст
не будет инвалидировать при изменении содержимого документов или их порядка.

{{> api_box cursor_rewind}}

Методы `forEach`, `map` и `fetch` могут быть вызваны для курсора только один
раз. Чтобы повторно получить информацию из курсора, его необходимо сбросить при
помощи метода `reset`.

{{> api_box cursor_observe}}

Создает *живой запрос*, который вызывает колбэки при изменении результатов
запроса. Колбэки получают новое содержимое измененного документа, и, по
возможности, его старое содержимое. Если вам нужны только измененные поля, то
используйте [`observeChanges`](#observe_changes).

Объект `callbacks` может содержать следующие свойства:

<dl class="callbacks">
<dt><span class="name">added(document)</span> <span class="or">или</span></dt>
<dt><span class="name">addedAt(document, atIndex, before)</span></dt>
<dd>
{{#markdown}}
В результатах запроса появился новый документ `document`. `atIndex` указывает
позицию нового документа, а `before` содержит `_id` документа, перед которым
он находится, или `null`, если новый документ является последним в списке.
{{/markdown}}
</dd>

<dt><span class="name">changed(newDocument, oldDocument)
    <span class="or">или</span></span></dt>
<dt><span class="name">changedAt(newDocument, oldDocument, atIndex)</span></dt>
<dd>
{{#markdown}}
Содержимое документа изменилось с `oldDocument` на `newDocument`. Позиция
измененного документа содержится в `atIndex`.
{{/markdown}}
</dd>

<dt><span class="name">removed(oldDocument)</span>
  <span class="or">или</span></dt>
<dt><span class="name">removedAt(oldDocument, atIndex)</span></dt>
<dd>
{{#markdown}}
Документ `oldDocument` изчез из результатов. Его позиция была `atIndex`.
{{/markdown}}
</dd>

{{#dtdd "movedTo(document, fromIndex, toIndex, before)"}}
Позиция документа изменилась с `fromIndex` на `toIndex`, и теперь он
находится перед документом с id `before`. Текущее содержимое документа
находится в `document`.
{{/dtdd}}
</dl>
Используйте `added`, `changed` и `removed`, если вам не важна позиция
документов в результате. Эти методы более эффективны, чем `addedAt`,
`changedAt` и `removedAt`.

Перед тем, как завершиться, метод `observe` вызывает колбэк `added` (или
`addedAt`) ноль или более раз, информируя о начальных результатах запроса.

`observe` возвращает хэндлер живого запроса, содержащий метод `stop`. При его
вызове, слежение за запросом прекращается и колбэки больше не вызываются.
**Если вы не вызовите этот метод, то живой запрос будет активен вечно.** Если
`observe` вызывается из `Deps.autorun`, то отслеживание запроса автоматически
прекращается при инвалидации или остановке реактивного контекста.

Если курсор был создан с опцией `reactive` равной `false`, то он
проинформирует только о своих начальных результатах запроса и не будет
вызывать последующие колбэки. Вызов метода `stop` хэндлера в этом случае не
обязателен.

{{> api_box cursor_observe_changes}}

Создает *живой запрос*, который вызывает колбэки при изменении результатов
запроса. В отличии от [`observe`](#observe), `observeChanges` предоставляет
только изменения в документах, а не содержимое документов полностью.

Объект `callbacks` может содержать следующие свойства:

<dl class="callbacks">
<dt><span class="name">added(id, fields)</span>
  <span class="or">или</span></dt>
<dt><span class="name">addedBefore(id, fields, before)</span></dt>
<dd>
{{#markdown}}
В результатах запроса появился новый документ с указанным id. В `fields`
содержатся все поля нового документа, за исключением поля `_id`. `before`
содержит id документа, перед которым он находится, или `null`, если новый
документ является последним в списке.
{{/markdown}}
</dd>

{{#dtdd "changed(id, fields)"}}
Документ с указанным `id` изменился. В `fields` содержатся измененные поля
документа с их новыми значениями. Если поле было удалено из документа, то его
значение в объекте `fields` будет `undefined`.
{{/dtdd}}

{{#dtdd "movedBefore(id, before)"}}
Позиция документа с указанными `id` изменилась, и теперь он находится перед
документом с id `before`.
{{/dtdd}}

{{#dtdd "removed(id)"}}
Документ с указанным `id` исчез из результатов запроса.
{{/dtdd}}
</dl>

Метод `observeChanges` работает на порядок эффективней, если вы не используете
колбэки `addedBefore` или `movedBefore`.

Перед тем, как завершиться, метод `observeChanges` вызывает колбэк `added` (или
`addedBefore`) ноль или более раз, информируя о начальных результатах запроса.

`observeChanges` возвращает хэндлер живого запроса, содержащий метод `stop`.
При его вызове, слежение за запросом прекращается и колбэки больше не
вызываются. **Если вы не вызовите этот метод, то живой запрос будет активен
вечно.** Если `observeChanges` вызывается из `Deps.autorun`, то отслеживание
запроса автоматически прекращается при инвалидации или остановке реактивного
контекста.

{{#note}}
В отличии от `observe`, `observeChanges` не предоставляет информации об
абсолютой позиции документа (параметр `atIndex` в колбэках). Это сделано в
целях повышения эффективности его работы.
{{/note}}

Пример:

    // Следим за количеством администраторов в онлайн.
    var count = 0;
    var query = Users.find({admin: true, onlineNow: true});
    var handle = query.observeChanges({
      added: function (id, user) {
        count++;
        console.log(user.name + " brings the total to " + count + " admins.");
      },
      removed: function () {
        count--;
        console.log("Lost one. We're now down to " + count + " admins.");
      }
    });

    // Прекращаем отслеживание через 5 секунд.
    setTimeout(function () {handle.stop();}, 5000);

{{> api_box collection_object_id}}

Класс `Meteor.Collection.ObjectID` предоставляет такое же API, как и [драйвер
MongoDB для Node](http://mongodb.github.com/node-mongodb-native/api-bson-generated/objectid.html).
Учтите, что для сравнения экземпляров этих объектов нужно использовать метод
`equals` (или [`EJSON.equals`](#ejson_equals)); оператор `===` работать не
будет. Если вы пишете универсальный код, который должен поддерживать работу с
полями `_id` как в виде строк, так и в виде объектов `ObjectID`, то для их
сравнения вам следует использовать [`EJSON.equals`](#ejson_equals).

{{#note}}
  Так как объекты `ObjectID` создаются в Meteor случайным образом, результаты
  вызова их методов `getTimestamp` на данный момент являются бессмысленными.
{{/note}}

{{#api_box selectors}}

Самые простые селекторы - это обычная строка или
[`Meteor.Collection.ObjectID`](#collection_object_id). Они указывают 
на документ с соответствующим `_id`.

Немного более сложная форма селектора - это объект с набором полей, которые
должны находиться в документе:

    // Matches all documents where deleted is false
    {deleted: false}

    // Соответствует всем документам, у которых поля "name" и "cognomen" имеют
    // указанные значения
    {name: "Rhialto", cognomen: "the Marvelous"}

    // Соответствует всем документам
    {}

Но селекторы могут содержать и более сложные условия:

    // Соответствует документам, у которых значение поля "age" больше 18
    {age: {$gt: 18}}

    // Соответствует документам, у которых поле "tags" является массивом,
    // содержащим значение "popular"
    {tags: "popular"}

    // Соответствует документам, у которых поле "fruit" может содержать одно
    // из трех указанных значений
    {fruit: {$in: ["peach", "plum", "pear"]}}

Полную документацию по селекторам можно прочитать
[здесь](http://docs.mongodb.org/manual/reference/operator/).

{{/api_box}}

{{#api_box modifiers}}

Модификатор - это объект, описывающий то, как должен быть изменен документ.
Вот несколько примеров:

    // Устанавливает полю "admin" документа значение true
    {$set: {admin: true}}

    // Увеличивает значение поля "votes" на 2 и добавляет значение "Traz"
    // в конец массива, хранящегося в поле "supporters"
    {$inc: {votes: 2}, $push: {supporters: "Traz"}}

Но если модификатор не содержит ни одного $-оператора, то он считается
полноценным документом и заменяет собой модифицируемые документы. (Такие
модификаторы в данный момент не поддерживаются [правилами изменения
коллекции]((#allow)).

    // Находим документ с id "123" и полностью его заменяем.
    Users.update({_id: "123"}, {name: "Alice", friends: ["Bob"]});

Полный список возможных модификаторов можно посмотреть
[здесь](http://www.mongodb.org/display/DOCS/Updating#Updating-ModifierOperations).

{{/api_box}}

{{#api_box sortspecifiers}}

Сортировка может быть указана несколькими различными способами:

    // Использование всех этих указателей эквивалентно: они сортируют по ключу
    // "a" в порядке возрастания и по ключу "b" в порядке убывания.

    [["a", "asc"], ["b", "desc"]]
    ["a", ["b", "desc"]]
    {a: 1, b: -1}

Последняя форма записи будет работать только если ваша реализация JavaScript
сохраняет порядок ключей в объектах. Большинство реализаций в большинстве
случаев его сохраняет, но вы должны в этом убедиться сами.

{{/api_box}}

{{#api_box fieldspecifiers}}

В запросах можно указывать список полей, которые вы хотите включить в
результат, или исключить из него.

Если вы хотите исключить некоторые поля из результата, то в качестве указателя
полей должен быть объект, ключами которого будут их названия, а значениями -
нули. Все неуказанные поля включаются в результат.

    // Users.find({}, {fields: {password: 0, hash: 0}})

Чтобы включить в результат только определенные поля, укажите в качестве их 
значения `1`. Поле `_id` в данном случае также добавляется в результат.

    // Users.find({}, {fields: {firstname: 1, lastname: 1}})

Невозможно одновременно включать и исключать поля кроме случая, когда поле
`_id` включено по-умолчанию и его нужно исключить. Однако, такие указатели 
полей не могут быть использованы с [`observeChanges`](#observe_changes),
[`observe`](#observe), курсорами, возвращаемыми из [функций
публикации](#meteor_publish) и курсорами, используемыми в хэлперах
`{{dstache}}#each}}` в шаблонах. Они могут быть использованы с
[`fetch`](#fetch), [`findOne`](#findone), [`forEach`](#foreach) и [`map`](#map).


<a href="http://docs.mongodb.org/manual/reference/operator/projection/">
Операторы в полях</a>, такие как `$` и `$elemMatch`), на клиенте пока не
поддерживаются.

Более сложный пример:

    Users.insert({ alterEgos: [{ name: "Kira", alliance: "murderer" },
                               { name: "L", alliance: "police" }],
                   name: "Yagami Light" });

    Users.findOne({}, { fields: { 'alterEgos.name': 1, _id: 0 } });

    // returns { alterEgos: [{ name: "Kira" }, { name: "L" }] }

Подробнее про правила обработки вложенных полей и массивов можно прочитать в
<a href="http://docs.mongodb.org/manual/tutorial/project-fields-from-query-results/#projection">
документации к MongoDB</a>.

{{/api_box}}

<h2 id="session"><span>Объект Session</span></h2>

`Session` - это глобальный объект на клиенте, предназначенный для хранения
разнообразных данных в виде "ключ-значение". Используйте его для хранения,
например, выделенного элемента списка.

Особенность объекта `Session` заключается в том, что он реактивный. Если вы
вызовите [`Session.get`](#session_get)`("currentList")` из шаблона, то при
вызове [`Session.set`](#session_set)`("currentList", x)` он перерисуется
автоматически.

{{> api_box session_set}}

Пример:

    Deps.autorun(function () {
      Meteor.subscribe("chat-history", {room: Session.get("currentRoomId")});
    });

    // Перезапускает колбэк, переданный в Deps.autorun, что приводит к
    // отписке от истории текущего чата и подписке на чат "home".
    Session.set("currentRoomId", "home");

{{> api_box setDefault}}

Данный метод удобно использовать во время инициализации приложения, чтобы
текущее значение переменной сессии не перетиралось ее начальным значением
каждый раз при загрузке новой версии приложения.

{{> api_box session_get}}

Пример:

    // в main.html
    {{lt}}template name="main">
      <p>We've always been at war with {{dstache}}theEnemy}}.</p>
    {{lt}}/template>

    // в main.js
    Template.main.helpers({
      theEnemy: function () {
        return Session.get("enemy");
      }
    });

    Session.set("enemy", "Eastasia");
    // На странице будет написано "We've always been at war with Eastasia"

    Session.set("enemy", "Eurasia");
    // Надпись изменится на "We've always been at war with Eurasia"


{{> api_box equals}}

Если значением является скаляр, то следующие выражения эквивалентны:

    (1) Session.get("key") === value
    (2) Session.equals("key", value)

... но использовать лучше второй вариант, т.к. в этом случае происходит меньше
инвалидаций (перерисовок шаблонов), что делает ваше приложение более
эффективным.

Пример:

    {{lt}}template name="postsView">
    {{dstache}}! Выводим динамически изменяющийся список постов.
        Пользователь может выбрать пост, кликнув не него.
        Выделенному посту добавляется CSS-класс, чтобы он отличался
        от других. }}

    {{dstache}}#each posts}}
      {{dstache}}> postItem }}
    {{dstache}}/each}}
    {{lt}}/template>

    {{lt}}template name="postItem">
      <div class="{{dstache}}postClass}}">{{dstache}}title}}</div>
    {{lt}}/template>

    ///// в JS-файле
    Template.postsView.posts = function() {
      return Posts.find();
    };

    Template.postItem.postClass = function() {
      return Session.equals("selectedPost", this._id) ?
        "selected" : "";
    };

    Template.postItem.events({
      'click': function() {
        Session.set("selectedPost", this._id);
      }
    });

    // Session.equals здесь используется для того, чтобы при клике
    // пользователя на пост, перерисовывался только он и пост,
    // выбранный до него.
    //
    // Если бы вместо Session.equals здесь использовалось Session.get, то
    // при выборе другого поста перерисовывались бы они все.

Если значением переменной сессии является объект или массив, то
`Session.equals` не может быть использована. В этом случае вам следует
воспользоваться пакетом `underscore` и выражением
`_.isEqual(Session.get(key), value)`.



<h2 id="accounts_api"><span>Учетные записи</span></h2>

Система учетных записей в Meteor построена на основе поддержки `userId`
публикациями и методами. Основные пакеты объявляют концепцию учетных записей
пользователей, хранящихся в БД в виде документов, а дополнительные пакеты
добавляют [безопасную аутентификацию при помощи пароля](#accounts_passwords),
[интеграцию со сторонними логин-сервисами](#meteor_loginwithexternalservice) и
[готовый пользовательский интерфейс](#accountsui).

Основным пакетом системы является `accounts-base`, который автоматически
добавляется в приложение при использовании одного из пакетов для
аутентификации: `accounts-password`, `accounts-facebook`,
`accounts-github`, `accounts-google`, `accounts-meetup`,
`accounts-twitter` или `accounts-weibo`.


{{> api_box user}}

Возвращает объект учетной записи текущего пользователя, полученный из
коллекции [`Meteor.users`](#meteor_users).

На клиенте будут доступны только опубликованные сервером поля учетной записи
текущего пользователя. По-умолчанию, сервер публикует поля  `username`,
`emails` и `profile`. Дополнительную информацию о полях, содержащихся в
учетных записях пользователей, можно прочитать в документации к коллекции
[`Meteor.users`](#meteor_users).

{{> api_box userId}}

{{> api_box users}}

Эта коллекция хранит по одному документу на каждого зарегистрированного
пользователя. Вот пример такого документа:

    {
      _id: "bbca5d6a-2156-41c4-89da-0329e8c99a4f",  // Meteor.userId()
      username: "cool_kid_13", // уникальное имя
      emails: [
        // Каждый email может принадлежить только одному пользователю.
        { address: "cool@example.com", verified: true },
        { address: "another@different.com", verified: false }
      ],
      createdAt: Wed Aug 21 2013 15:16:52 GMT-0700 (PDT),
      profile: {
        // По-умолчанию, пользователь может изменять свой объект 'profile'.
        name: "Joe Schmoe"
      },
      services: {
        facebook: {
          id: "709050", // facebook id
          accessToken: "AAACCgdX7G2...AbV9AZDZD"
        },
        resume: {
          loginTokens: [
            { token: "97e8c205-c7e4-47c9-9bea-8e2ccc0694cd",
              when: 1349761684048 }
          ]
        }
      }
    }

В документе пользователя можно хранить любые необходимые вам данные.
Следующие поля Meteor обрабатывает особенным образом:

- `username`: уникальное имя пользователя (строка).
- `emails`: массив объектов, содержащих поля `address` и `verified`;
  Каждый email может принадлежать только одному пользователю.
  Поле `verified` имеет тип Boolean и принимает значение `true`, если
  пользователь [подтвердил данный адрес](#accounts_verifyemail) при
  помощи токена, полученного по email.
- `createdAt`: дата создания документа пользователя (тип Date).
- `profile`: объект, который по-умолчанию пользователь может создавать и
  изменять.
- `services`: объект, содержищий необходимую для сервисов аутентификации
  информацию (например, токены логин-сервисов и токены для [сброса
  пароля](#accounts_forgotpassword)).

Как и при работе с другими [коллекциями](#collections), на сервере вы можете
получить доступ ко всем документам `Meteor.users`, но на клиенте вам доступны
лишь опубликованные сервером.

По-умолчанию, публикуются только поля `username`, `emails` и `profile`
текущего залогиненного пользователя. Опубликовать дополнительные поля вы
можете следующим образом:

    // На сервере
    Meteor.publish("userData", function () {
      if (this.userId) {
        return Meteor.users.find({_id: this.userId},
                                 {fields: {'other': 1, 'things': 1}});
      } else {
        this.ready();
      }
    });

    // На клиенте
    Meteor.subscribe("userData");

Если ваше приложение использует пакет `autopublish`, то информация обо всех
пользователях будет опубликована для всех клиентов. Эта информация включает
поля `username`, `profile` и все "публичные" данные из объекта `services`
(например, `services.facebook.id` и `services.twitter.screenName`). Также, в
этом случае, публикуется больше информации о текущем залогиненном
пользователе, например его токены для логин-сервисов. Это позволяет
использовать их API напрямую с клиента.

По-умолчанию, пользователи могут установить себе поле `profile` при помощи
метода [`Accounts.createUser`](#accounts_createuser) и изменять его с помощью
`Meteor.users.update`. Чтобы разрешить пользователям менять дополнительные
поля, используйте [`Meteor.users.allow`](#allow). Чтобы запретить
пользователям вносить какие-либо изменения в их учетные записи, используйте
следующий код:

    Meteor.users.deny({update: function () { return true; }});


{{> api_box loggingIn}}

Пакет [`accounts-ui`](#accountsui), например, использует этот метод для
показа анимации во время обработки запроса пользователя на вход в приложение.

{{> api_box logout}}

{{> api_box logoutOtherClients}}

Если, например, данная функция будет вызвана из браузера пользователя, то в
нем он останется залогиненным, но будет разлогинен во всех других браузерах.

{{> api_box loginWithPassword}}

Эта функция доступна при использовании пакета `accounts-password`. Смотрите
главу [Пароли](#accounts_passwords).


{{> api_box loginWithExternalService}}

Список доступных функций:

* `Meteor.loginWithMeteorDeveloperAccount`
* `Meteor.loginWithFacebook`
* `Meteor.loginWithGithub`
* `Meteor.loginWithGoogle`
* `Meteor.loginWithMeetup`
* `Meteor.loginWithTwitter`
* `Meteor.loginWithWeibo`

Эти функции инициируют процесс логина пользователя с помощью сторонних
сервисов (например, Facebook, Google и т.д.), используя OAuth. При вызове они
открывают страницу логина соответствующего сервиса в новом окне браузера.
После того, как пользователь залогинится в сервисе, это окно закрывается и
пользователь логинится в ваше приложение, используя информацию,
предоставленную сторонним сервисом.

<a id="requestpermissions" name="requestpermissions" />

Некоторые сервисы, помимо идентификации пользователя, предоставляют доступ к
своим API, которые позволяют выполнять действия от имени пользователя. Чтобы
запросить у пользователя дополнительные разрешения, передайте их в качестве
значения опции `requestPermissions` функции логина. В этом случае в попапе
логина пользователю будет показана дополнительная страница, запрашивающая у
него необходимые вам права. Полученный в результате токен доступа будет
сохранен в поле `services` учетной записи пользователя. Список возможных
разрешений (`requestPermissions`) различается от сервиса к сервису. Узнать о
них можно на соответствующих страницах руководств для разработчиков:

- Facebook: <http://developers.facebook.com/docs/authentication/permissions/>
- GitHub: <http://developer.github.com/v3/oauth/#scopes>
- Google: <https://developers.google.com/accounts/docs/OAuth2Login#scopeparameter>
- Meetup: <http://www.meetup.com/meetup_api/auth/#oauth2-scopes>
- Twitter, Weibo, Meteor developer accounts: опция `requestPermissions` в данный момент не поддерживается

Обычно перед использованием сторонних логин-сервисов необходима регистрация в
них вашего приложения и его настройка. Самый простой способ это сделать - это
воспользоваться пакетом [`accounts-ui`](#accountsui), который содержит
пошаговое руководство для настройки каждого сервиса. Однако, вы можете
настроить их вручную, добавив всю необходимую информацию в коллекцию
`ServiceConfiguration.configurations`, которая становится доступна при 
подключении пакета `service-configuration`:

    // Сначала удаляем уже существующие настройки для сервиса
    // (если таковые имеются)
    ServiceConfiguration.configurations.remove({
      service: "weibo"
    });
    ServiceConfiguration.configurations.insert({
      service: "weibo",
      clientId: "1292962797",
      secret: "75a730b58f5691de5522789070c319bc"
    });


Каждый сторонний сервис хранится в отдельном пакете и имеет собственную
функцию логина. Например, для того, чтобы добавить поддержку логина с помощью
GitHub, выполните команду `$ meteor add accounts-github` и используйте
функцию `Meteor.loginWithGithub`:

    Meteor.loginWithGithub({
      requestPermissions: ['user', 'public_repo']
    }, function (err) {
      if (err)
        Session.set('errorMessage', err.reason || 'Unknown error');
    });



{{> api_box currentUser}}
{{> api_box loggingInTemplate}}
{{> api_box accounts_config}}
{{> api_box accounts_ui_config}}

Пример:

    Accounts.ui.config({
      requestPermissions: {
        facebook: ['user_likes'],
        github: ['user', 'repo']
      },
      requestOfflineToken: {
        google: true
      },
      passwordSignupFields: 'USERNAME_AND_OPTIONAL_EMAIL'
    });

{{> api_box accounts_validateNewUser}}

Эта функция может быть вызвана несколько раз. Если хотя бы один из колбэков
вернет `false` или возбудит исключение, создание нового пользователя будет
запрещено. Чтобы указать сообщение об ошибке (которое будет показано в форме
создания нового пользователя при использовании пакета
[`accounts-ui`](#accountsui)), возбудите исключение
[`Meteor.Error`](#meteor_error).

Пример:

    // Проверяем имя пользователя и показываем соответствующее
    // сообщение об ошибке.
    Accounts.validateNewUser(function (user) {
      if (user.username && user.username.length >= 3)
        return true;
      throw new Meteor.Error(403, "Username must have at least 3 characters");
    });
    // Проверяем имя пользователя, не показывая сообщение об ошибке.
    Accounts.validateNewUser(function (user) {
      return user.username !== "root";
    });

If the user is being created as part of a login attempt from a client (eg,
calling [`Accounts.createUser`](#accounts_createuser) from the client, or
[logging in for the first time with an external
service](#meteor_loginwithexternalservice)), these callbacks are called *before*
the [`Accounts.validateLoginAttempt`](#accounts_validateloginattempt)
callbacks. If these callbacks succeed but those fail, the user will still be
created but the connection will not be logged in as that user.

{{> api_box accounts_onCreateUser}}

Используйте эту функцию в случае, если вам нужно не просто разрешить или
запретить создание нового пользователя. С помощью нее вы можете
контролировать содержимое учетных записей новых пользователей.

В указанный вами колбэк будет передано два аргумента: `options` и `user`.
Агрумент `options` передается из
[`Accounts.createUser`](#accounts_createuser) в случае создания учетной
записи, защищенной паролем, либо получается от стороннего логин-сервиса.
Обязательно проверяйте всю информацию, хранящуюся в нем, т.к. она может прийти
из недоверенных источников. Аргумент `user` содержит сгененированный на
сервере объект учетной записи пользователя, содержащий все необходимые для
его логина поля.

Функция должна вернуть новый объект учетной записи пользователя (либо
переданный в нее объект `user`, либо какой-либо другой созданный вами объект),
содержащий все необходимые изменения, который затем будет добавлен в коллекцию
[`Meteor.users`](#meteor_users).

По-умолчанию, функция создания нового пользователя просто копирует
`options.profile` в объект его учетной записи. Вызывая `onCreateUser`, вы
переопределяете это поведение. Таким образом, функцию `onCreateUser` можно
вызывать только один раз.

Пример:

<!-- XXX replace d6 with _.random once we have underscore 1.4.2 -->

    // Поддержка для игры в D&D: Бросаем кубик 3 раза, чтобы получить
    // "ловкость" пользователя
    Accounts.onCreateUser(function(options, user) {
      var d6 = function () { return Math.floor(Random.fraction() * 6) + 1; };
      user.dexterity = d6() + d6() + d6();
      // Повторяем поведение функции создания нового пользователя по-умолчанию.
      if (options.profile)
        user.profile = options.profile;
      return user;
    });


{{> api_box accounts_validateLoginAttempt}}

Call `validateLoginAttempt` with a callback to be called on login
attempts.  It returns an object with a single method, `stop`.  Calling
`stop()` unregisters the callback.

When a login attempt is made, the registered validate login callbacks
are called with a single argument, the attempt info object:

<dl class="objdesc">
{{#dtdd name="type" type="String"}}
  The service name, such as "password" or "twitter".
{{/dtdd}}

{{#dtdd name="allowed" type="Boolean"}}
  Whether this login is allowed and will be successful (if not aborted
  by any of the validateLoginAttempt callbacks).  False if the login
  will not succeed (for example, an invalid password or the login was
  aborted by a previous validateLoginAttempt callback).
{{/dtdd}}

{{#dtdd name="error" type="Exception"}}
  When `allowed` is false, the exception describing why the login
  failed.  It will be a `Meteor.Error` for failures reported to the
  user (such as invalid password), and can be a another kind of
  exception for internal errors.
{{/dtdd}}

{{#dtdd name="user" type="Object"}}
  When it is known which user was attempting to login, the Meteor user
  object.  This will always be present for successful logins.
{{/dtdd}}

{{#dtdd name="connection" type="Object"}}
  The `connection` object the request came in on. See
  [`Meteor.onConnection`](#meteor_onconnection) for details.
{{/dtdd}}

{{#dtdd name="methodName" type="String"}}
  The name of the Meteor method being used to login.
{{/dtdd}}

{{#dtdd name="methodArguments" type="Array"}}
  An array of the arguments passed to the login method.
{{/dtdd}}
</dl>

A validate login callback must return a truthy value for the login to
proceed.  If the callback returns a falsy value or throws an
exception, the login is aborted.  Throwing a `Meteor.Error` will
report the error reason to the user.

All registered validate login callbacks are called, even if one of the
callbacks aborts the login.  The later callbacks will see the
`allowed` field set to `false` since the login will now not be
successful.


{{> api_box accounts_onLogin}}

Either the `onLogin` or the `onLoginFailure` callbacks will be called
for each login attempt. The `onLogin` callbacks are called after the
user has been successfully logged in. The `onLoginFailure` callbacks are
called after a login attempt is denied.

These functions return an object with a single method, `stop`.  Calling
`stop()` unregisters the callback.

The callbacks are called with a single argument, the same attempt info
object as [`validateLoginAttempt`](#accounts_validateloginattempt).


<h2 id="accounts_passwords"><span>Пароли</span></h2>

Пакет `accounts-password` содержит систему аутентификации пользователей при
помощи пароля. В дополнение к основному функционалу входа в систему на
основе имени пользователя и пароля, пакет также поддерживает вход при помощи
email-адреса, его подтверждение и отсылку писем для восстановления пароля.

В отличии от большинства веб-приложений, Meteor-клиент не отсылает пароль на
сервер в голом виде. Для его шифрования он использует протокол [Secure Remote
Password](http://en.wikipedia.org/wiki/Secure_Remote_Password_protocol). Это
помогает защитить пароли пользователей в случае, если безопасность базы
данных скомпрометирована.

Чтобы добавить поддержку паролей в ваше приложение, выполните команду
`$ meteor add accounts-password`. Вы можете создать свой собственный интерфейс
пользователя, используя функции, описанные ниже, или же воспользоваться
[пакетом `accounts-ui`](#accountsui), содержащим уже готовый интерфейс для
аутентификации пользователей при помощи пароля.


{{> api_box accounts_createUser}}

На клиенте эта функция логинит пользователя под новой учетной записью, в
случае успешного ее создания. На сервере она возвращает id созданной
учетной записи.

На клиенте для создания нового пользователя вам необходимо указать его пароль
(`password`) и либо его имя (`username`), либо `email` &mdash; это
минимальное количество информации, необходимое для последующего успешного
логина. На сервере вы можете не указывать пароль, но пользователь не сможет 
залогиниться до тех пор, пока вы его не установите (например, при помощи
[`Accounts.setPassword`](#accounts_setpassword)).

Чтобы на сервере создать учетную запись без пароля, но дать пользователю
возможность установить его самому, вызовите `createUser`, указав `email`, а
затем вызовите
[`Accounts.sendEnrollmentEmail`](#accounts_sendenrollmentemail). После этого
пользователю будет отправлено письмо со ссылкой для установки пароля.

По-умолчанию, объект `profile` напрямую записывается в учетную запись
пользователя. Изменить это поведение можно при помощи функции
[`Accounts.onCreateUser`](#accounts_oncreateuser).

Эта функция используется только для создания пользователей с паролями.
При логине пользователей при помощи сторонних сервисов она не используется.


{{> api_box accounts_changePassword}}

{{> api_box accounts_forgotPassword}}

Эта функция вызывает серверный метод
[`Accounts.sendResetPasswordEmail`](#accounts_sendresetpasswordemail). Чтобы
завершить процесс сброса пароля, необходимо передать токен из отосланного
пользователю письма в функцию
[`Accounts.resetPassword`](#accounts_resetpassword).

Если вы используете [пакет `accounts-ui`](#accountsui), то все это делается
автоматически. В противном случае, вы должны сами показать пользователю
диалог ввода нового пароля и заменить им старый, вызвав функцию
`resetPassword`.

{{> api_box accounts_resetPassword}}

Эта функция принимает токены, созданные методами
[`Accounts.sendResetPasswordEmail`](#accounts_sendresetpasswordemail) и
[`Accounts.sendEnrollmentEmail`](#accounts_sendenrollmentemail).

{{> api_box accounts_setPassword}}

{{> api_box accounts_verifyEmail}}

Эта функция принимает токены, созданные методом
[`Accounts.sendVerificationEmail`](#accounts_sendverificationemail). Она
меняет значение поля `emails.verified` в учетной записи пользователя.

{{> api_box accounts_sendResetPasswordEmail}}

Токен из данного письма должен быть передан в функцию
[`Accounts.resetPassword`](#accounts_resetpassword).

Информацию о том, как настроить содержимое отсылаемых писем, можно найти в
документации к [`Accounts.emailTemplates`](#accounts_emailtemplates).

{{> api_box accounts_sendEnrollmentEmail}}

Токен из данного письма должен быть передан в функцию
[`Accounts.resetPassword`](#accounts_resetpassword).

Информацию о том, как настроить содержимое отсылаемых писем, можно найти в
документации к [`Accounts.emailTemplates`](#accounts_emailtemplates).

{{> api_box accounts_sendVerificationEmail}}

Токен из данного письма должен быть передан в функцию
[`Accounts.verifyEmail`](#accounts_verifyemail).

Информацию о том, как настроить содержимое отсылаемых писем, можно найти в
документации к [`Accounts.emailTemplates`](#accounts_emailtemplates).

{{> api_box accounts_emailTemplates}}

Этот объект служит для настройки содержимого писем, отправляемых функциями
`sendResetPasswordEmail`, `sendEnrollmentEmail` и `sendVerificationEmail`.

Объект содержит следующие свойства:

- `from`: Строка, содержащая адрес отправителя в формате
   [RFC5322](http://tools.ietf.org/html/rfc5322). По-умолчанию, письмо
   отправляется с `no-reply@meteor.com`. Если вы хотите получать письма от
   пользователей, испытывающих проблемы со свой учетной записью, то здесь
   необходимо указать адрес, на который они смогут отсылать вам письма.
- `siteName`: Публичное название вашего приложения. По-умолчанию, содержит
   DNS-имя вашего приложения (напрмер, `awesome.meteor.com`).
- `resetPassword`: Объект с двумя свойствами:
 - `resetPassword.subject`: Функция, принимающая объект учетной записи
   пользователя и возвращающая заголовок письма для сброса пароля в виде
   строки.
 - `resetPassword.text`: Функция, принимающая объект учетной записи
   пользователя и URL и возвращающая текст письма для сброса пароля в виде
   строки.
 - `resetPassword.html`: Необязательная функция, принимающая объект учетной
   записи пользователя и URL и возвращающая HTML письма для сброса пароля в виде
   строки.
- `enrollAccount`: То же, что и `resetPassword`, но для установки начального
   пароля для новых учетных записей.
- `verifyEmail`: То же, что и `resetPassword`, но для подтверждения
   email-адресов пользователя.


Пример:

    Accounts.emailTemplates.siteName = "ЧудоСайт";
    Accounts.emailTemplates.from = "Админ ЧудоСайта <accounts@example.com>";
    Accounts.emailTemplates.enrollAccount.subject = function (user) {
        return "Добро пожаловать в Чудо-Город, " + user.profile.name;
    };
    Accounts.emailTemplates.enrollAccount.text = function (user, url) {
       return "Вас выбрали для участия в строительстве лучшего будущего! "
         + "Чтобы активировать вашу учетную запись, просто пройдите по "
         + "данной ссылке:\n\n"
         + url;
    };


<h2 id="templates_api"><span>Шаблоны</span></h2>


Когда в HTML-файле вы объявляете шаблон вида
`<{{! }}template name="foo"> ... <{{!}}/template>`, Meteor создает "объект 
компонента" и сохраняет его под именем `Template.foo`.
    
{{#note}}
   Meteor's component API is currently in flux. This section documents a few
   features of the component object that are useful for writing apps; a future
   release will elaborate more about how components work and about how to build
   components that aren't just template.
{{/note}}

Один и тот же шаблон может быть отрисован на странице множество раз. Каждая
такая отрисовка называется экземпляром шаблона. Жизненный цикл экземпляра
шаблона можно разделить на несколько этапов: его создание, вставка на
страницу и последующее изъятие со страницы и уничтожение. Meteor управляет
всеми этими этапами без вашего вмешательства. Он даже самостоятельно
определяет, что экземпляр шаблона был изъят со страницы, и уничтожает его. К
экземпляру шаблона можно привязать какие-либо данные, а также обращаться к
его DOM-узлам.


{{> api_box template_events}}

Declare event handlers for instances of this template. Multiple calls add
new event handlers in addition to the existing ones.

See [Event Maps](#eventmaps) for a detailed description of the event
map format and how event handling works in Meteor.

{{> api_box template_helpers}}

Each template has a local dictionary of helpers that are made available to it,
and this call specifies helpers to add to the template's dictionary.

Example:

    Template.myTemplate.helpers({
      foo: function () {
        return Session.get("foo");
      }
    });

Now you can invoke this helper with `{{dstache}}foo}}` in the template defined
with `<{{! }}template name="myTemplate">`.

The following syntax is a shorthand for when you only have one helper to define:

    Template.myTemplate.foo = function () {
      return Session.get("foo");
    };

To create a helper that can be used in any template, use
[`UI.registerHelper`](#ui_registerhelper).


{{> api_box template_rendered}}

This callback is called once when an instance of Template.*myTemplate* is
rendered into DOM nodes and put into the document for the first time.

In the body of the callback, `this` is a [template
instance](#template_inst) object that is unique to this occurrence of
the template and persists across re-renderings.  Use the `created` and
`destroyed` callbacks to perform initialization or clean-up on the
object.

Because your template has been rendered, you can use functions like
`this.findAll` which look at its DOM nodes.

{{> api_box template_created}}

This callback is called before your template's logic is evaluated for the first
time.  Inside the callback, `this` is the new [template
instance](#template_inst) object.  Properties you set on this object will be
visible from the `rendered` and `destroyed` callbacks and from event handlers.

This callback fires once and is the first callback to fire.  Every
`created` has a corresponding `destroyed`; that is, if you get a
`created` callback with a certain template instance object in `this`,
you will eventually get a `destroyed` callback for the same object.

{{#note}}
  The `created` callback is not currently very useful. In a later release, the
  template instance object (or something like it) will be visible from helper
  functions, and `created` will be a useful way to set up values that are read
  from helpers. For now, you probably just want to use `rendered`.
{{/note}}

{{> api_box template_destroyed}}

This callback is called when an occurrence of a template is taken off
the page for any reason and not replaced with a re-rendering.  Inside
the callback, `this` is the [template instance](#template_inst) object
being destroyed.

This callback is most useful for cleaning up or undoing any external effects of
`created` or `rendered`.  It fires once and is the last callback to fire.


<h2 id="template_inst"><span>Template instances</span></h2>

A template instance object represents an occurrence of a template in
the document.  It can be used to access the DOM and it can be
assigned properties that persist as the template is reactively updated.

Template instance objects are found as the value of `this` in the
`created`, `rendered`, and `destroyed` template callbacks, and as an
argument to event handlers.

{{#note}}
  You cannot currently access the template instance object from helpers.
  We plan to refactor how template instances work and make them more
  universally accessible.
{{/note}}

In addition to the properties and functions described below, you can assign
additional properties of your choice to the object. Use the
[`created`](#template_created) and [`destroyed`](#template_destroyed) callbacks
to perform initialization or clean-up on the object.

You can only access `findAll`, `find`, `firstNode`, and `lastNode`
from the `rendered` callback and event handlers, not from `created`
and `destroyed`, because they require the template instance to be
in the DOM.

{{> api_box template_findAll}}

Returns a [jQuery object](http://api.jquery.com/Types/#jQuery) of DOM elements
matching `selector`. This object is similar to an array but has other methods
defined by the jQuery library.

You can also call this function as `this.$(selector)`.

The template instance serves as the document root for the selector. Only
elements inside the template and its sub-templates can match parts of
the selector.

{{> api_box template_find}}

Returns one DOM element matching `selector`, or `null` if there are no
such elements.

The template instance serves as the document root for the selector. Only
elements inside the template and its sub-templates can match parts of
the selector.

{{> api_box template_firstNode}}

The two nodes `firstNode` and `lastNode` indicate the extent of the
rendered template in the DOM.  The rendered template includes these
nodes, their intervening siblings, and their descendents.  These two
nodes are siblings (they have the same parent), and `lastNode` comes
after `firstNode`, or else they are the same node.

{{> api_box template_lastNode}}

{{> api_box template_data}}

This property provides access to the data context at the top level of
the template.  It is updated each time the template is re-rendered.
Access is read-only and non-reactive.


<h2 id="ui"><span>Template utilities</span></h2>

The `UI` namespace contains several utilities that are helpful when writing your
user interface.  `UI.registerHelper` allows you to define helper functions which
you can use in every template.  `UI.render`, `UI.renderWithData`, and
`UI.insert` allow you to manually render templates and insert them directly into
any part of the DOM for finer control than just using template inclusions.

{{> api_box ui_registerhelper}}

{{> api_box ui_body}}

You can define helpers and event maps on `UI.body` just like on any
`Template.myTemplate` object.

{{> api_box ui_render}}

This returns an "instantiated component" object, which can be passed to
[`UI.insert`](#ui_insert). The template's [`created`](#template_created) callback
will be invoked.  The component will continue to be updated reactively as the
data used changes.

{{#warning}}
  Future releases will provide a richer API for "instantiated components"
  (probably unifying them with "template instances"). For now, all you can
  do with them is pass them to `UI.insert`.

  Most users will not need to manually render components or manually insert them
  into the DOM at all.  As of 0.8.0, if you call `UI.render` and never insert
  the result into the DOM, the logic to keep the instantiated component updated
  will continue running in your browser forever. Additionally, if you remove any
  part of your DOM using any mechanism other than jQuery, the logic to keep that
  part of the the DOM updated will continue running.  To avoid these issues,
  either avoid directly updating the DOM or ensure that any removals go through
  jQuery.
{{/warning}}

{{> api_box ui_renderwithdata}}

{{> api_box ui_insert}}



{{#api_box eventmaps}}

Several functions take event maps. An event map is an object where
the properties specify a set of events to handle, and the values are
the handlers for those events. The property can be in one of several
forms:

<dl>
{{#dtdd "<em>eventtype</em>"}}
Matches a particular type of event, such as 'click'.
{{/dtdd}}

{{#dtdd "<em>eventtype selector</em>"}}
Matches a particular type of event, but only when it appears on
an element that matches a certain CSS selector.
{{/dtdd}}

{{#dtdd "<em>event1, event2</em>"}}
To handle more than one type of event with the same function, use a
comma-separated list.
{{/dtdd}}
</dl>

The handler function receives two arguments: `event`, an object with
information about the event, and `template`, a [template
instance](#template_inst) for the template where the handler is
defined.  The handler also receives some additional context data in
`this`, depending on the context of the current element handling the
event.  In a template, an element's context is the
data context where that element occurs, which is set by
block helpers such as `#with` and `#each`.

Example:

    {
      // Fires when any element is clicked
      'click': function (event) { ... },

      // Fires when any element with the 'accept' class is clicked
      'click .accept': function (event) { ... },

      // Fires when 'accept' is clicked, or a key is pressed
      'keydown, click .accept': function (event) { ... }
    }

Most events bubble up the document tree from their originating
element.  For example, `'click p'` catches a click anywhere in a
paragraph, even if the click originated on a link, span, or some other
element inside the paragraph.  The originating element of the event
is available as the `target` property, while the element that matched
the selector and is currently handling it is called `currentTarget`.

    {
      'click p': function (event) {
        var paragraph = event.currentTarget; // always a P
        var clickedElement = event.target; // could be the P or a child element
      }
    }

If a selector matches multiple elements that an event bubbles to, it
will be called multiple times, for example in the case of `'click
div'` or `'click *'`.  If no selector is given, the handler
will only be called once, on the original target element.

The following properties and methods are available on the event object
passed to handlers:

<dl class="objdesc">
{{#dtdd name="type" type="String"}}
The event's type, such as "click", "blur" or "keypress".
{{/dtdd}}

{{#dtdd name="target" type="DOM Element"}}
The element that originated the event.
{{/dtdd}}

{{#dtdd name="currentTarget" type="DOM Element"}}
The element currently handling the event.  This is the element that
matched the selector in the event map.  For events that bubble, it may
be `target` or an ancestor of `target`, and its value changes as the
event bubbles.
{{/dtdd}}

{{#dtdd name="which" type="Number"}}
For mouse events, the number of the mouse button (1=left, 2=middle, 3=right).
For key events, a character or key code.
{{/dtdd}}

{{#dtdd "stopPropagation()"}}
Prevent the event from propagating (bubbling) up to other elements.
Other event handlers matching the same element are still fired, in
this and other event maps.
{{/dtdd}}

{{#dtdd "stopImmediatePropagation()"}}
Prevent all additional event handlers from being run on this event,
including other handlers in this event map, handlers reached by
bubbling, and handlers in other event maps.
{{/dtdd}}

{{#dtdd "preventDefault()"}}
Prevents the action the browser would normally take in response to this
event, such as following a link or submitting a form.  Further handlers
are still called, but cannot reverse the effect.
{{/dtdd}}

{{#dtdd "isPropagationStopped()"}}
Returns whether `stopPropagation()` has been called for this event.
{{/dtdd}}

{{#dtdd "isImmediatePropagationStopped()"}}
Returns whether `stopImmediatePropagation()` has been called for this event.
{{/dtdd}}

{{#dtdd "isDefaultPrevented()"}}
Returns whether `preventDefault()` has been called for this event.
{{/dtdd}}
</dl>

Returning `false` from a handler is the same as calling
both `stopImmediatePropagation` and `preventDefault` on the event.

Event types and their uses include:

<dl class="objdesc">
{{#dtdd "<code>click</code>"}}
Mouse click on any element, including a link, button, form control, or div.
Use `preventDefault()` to prevent a clicked link from being followed.
Some ways of activating an element from the keyboard also fire `click`.
{{/dtdd}}

{{#dtdd "<code>dblclick</code>"}}
Double-click.
{{/dtdd}}

{{#dtdd "<code>focus, blur</code>"}}
A text input field or other form control gains or loses focus.  You
can make any element focusable by giving it a `tabindex` property.
Browsers differ on whether links, checkboxes, and radio buttons are
natively focusable.  These events do not bubble.
{{/dtdd}}

{{#dtdd "<code>change</code>"}}
A checkbox or radio button changes state.  For text fields, use
`blur` or key events to respond to changes.
{{/dtdd}}

{{#dtdd "<code>mouseenter, mouseleave</code>"}} The pointer enters or
leaves the bounds of an element.  These events do not bubble.
{{/dtdd}}

{{#dtdd "<code>mousedown, mouseup</code>"}}
The mouse button is newly down or up.
{{/dtdd}}

{{#dtdd "<code>keydown, keypress, keyup</code>"}}
The user presses a keyboard key.  `keypress` is most useful for
catching typing in text fields, while `keydown` and `keyup` can be
used for arrow keys or modifier keys.
{{/dtdd}}

</dl>

Other DOM events are available as well, but for the events above,
Meteor has taken some care to ensure that they work uniformly in all
browsers.

{{/api_box}}


<h2 id="match"><span>Объект Match</span></h2>

Методы и публикации в Meteor принимают любые [EJSON](#ejson)-совместимые
аргументы, но в большинстве случаев мы хотим, чтобы они были определенного
типа. Пакет `check` содержит маленькую библиотеку, предназначенную для
проверки типа объектов. Например:

    Meteor.publish("chats-in-room", function (roomId) {
      // Проверяем, что roomId содержит строку, а не произвольный
      // Mongo-селектор.
      check(roomId, String);
      return Chats.find({room: roomId});
    });

    Meteor.methods({addChat: function (roomId, message) {
      check(roomId, String);
      check(message, {
        text: String,
        timestamp: Date,
        // Необязательное поле, но если присутствует, то должно содержать
        // массив строк.
        tags: Match.Optional([String])
      });

      // ... Делаем что-то с сообщением ...
    }});

{{> api_box check}}

Если значение не прошло проверку, `check` возбуждает исключение
`Match.Error`, содержащее причину неудачи. Если эта ошибка отсылается обратно
клиенту, то для него она преобразуется в `Meteor.Error(400, "Match Failed")`,
т.е. дополнительную информацию об ошибке клиент не получает - она
записывается в логи сервера.

{{> api_box match_test}}

{{#api_box matchpatterns}}

Шаблоны значений, передаваемые в функции `check` и `Match.test`, могут быть
следующих видов:


<dl>
{{#dtdd "<code>Match.Any</code>"}}
Соответствует любому значению.
{{/dtdd}}

{{#dtdd "<code>String</code>, <code>Number</code>, <code>Boolean</code>, <code>undefined</code>, <code>null</code>"}}
Соответствует примитиву указанного типа.
{{/dtdd}}

{{#dtdd "<code>Match.Integer</code>"}}
Соответствует 32-разрядному целому со знаком. Не соответствует значениям
`Infinity`, `-Infinity` или `NaN`.
{{/dtdd}}

{{#dtdd "<code>[<em>pattern</em>]</code>"}}
Массив из одного элемента соответствует массиву значений, каждое из которых
соответствует шаблону *pattern*. Например, `[Number]` соответствует массиву
чисел (возможно пустому), а `[Match.Any]` - любому массиву.
{{/dtdd}}

{{#dtdd "<code>{<em>key1</em>: <em>pattern1</em>, <em>key2</em>: <em>pattern2</em>, ...}</code>"}}
Соответствует объекту с указанными ключами, значение каждого из которых
соответствует определенному шаблону. Если в качестве шаблона для ключа
используется `Match.Optional`, то этот ключ в объекте может не существовать.
Объект должен содержать только перечисленные ключи и быть простым объектом
(экземпляром Object).
{{/dtdd}}

{{#dtdd "<code>Match.ObjectIncluding({<em>key1</em>: <em>pattern1</em>, <em>key2</em>: <em>pattern2</em>, ...})</code>"}}
Соответствует простому объекту с указанными ключами. Помимо них объект может
содержать и другие ключи с произвольными значениями.
{{/dtdd}}

{{#dtdd "<code>Object</code>"}}
Соответствует любому простому объекту с любыми ключами. Равносильно
`Match.ObjectIncluding({})`.
{{/dtdd}}

{{#dtdd "<code>Match.Optional(<em>pattern</em>)</code>"}}
Соответствует либо `undefined`, либо значению, удовлетворяющему указанному
шаблону. Если используется в качестве шаблона для значения ключа в объекте,
то для того, чтобы проверка была успешна, ключ должен отсутствовать, а не
иметь значение `undefined`.

    // В объекте
    var pat = { name: Match.Optional(String) };
    check({ name: "something" }, pat) // OK
    check({}, pat) // OK
    check({ name: undefined }, pat) // Возбуждает исключение

    // Не в объекте
    check(undefined, Match.Optional(String)); // OK

{{/dtdd}}

{{#dtdd "<code>Match.OneOf(<em>pattern1</em>, <em>pattern2</em>, ...)</code>"}}
Соответствует значению, которое удовлетворяет хотя бы одному из указанных
шиблонов.
{{/dtdd}}

{{#dtdd "Конструктор любого объекта (например, <code>Date</code>)"}}
Соответствует любому объекту, который является экземпляром указанного типа.
{{/dtdd}}

{{#dtdd "<code>Match.Where(<em>condition</em>)</code>"}}
Вызывает функцию *condition* и передает ей проверяемое значение. Если она
возвращает `true`, проверка считается успешной. Если она возвращает `false`
или возбуждает исключение `Match.Error`, то проверка считается неудачной.
Если она возбуждает любой другой тип исключения, то оно не перехватывается.
Примеры:

    check(buffer, Match.Where(EJSON.isBinary));

    NonEmptyString = Match.Where(function (x) {
      check(x, String);
      return x.length > 0;
    });
    check(arg, NonEmptyString);
{{/dtdd}}
</dl>

{{/api_box}}

<h2 id="timers"><span>Таймеры</span></h2>

Для того, чтобы отслеживать некоторые вещи, например, текущего пользователя
для обрабатываемого запроса, Meteor использует глобальные переменные среды.
Для того, чтобы эти переменные имели правильные значения, вместо `setTimeout`
и `setInterval` вам необходимо использовать соответсвенно `Meteor.setTimeout`
и `Meteor.setInterval`.

Эти функции работаю точно так же, как и их нативные JavaScript-реализации.
Если вы вызовите нативную функцию, то получите сообщение об ошибке, информирующее о том, что код Meteor-а должен выполняться в волокне (Fiber) и советующее использовать `Meteor.bindEnvironment`.

{{> api_box setTimeout}}

Возвращает дескриптор, которые используется при вызове `Meteor.clearTimeout`.

{{> api_box setInterval}}

Возвращает дескриптор, которые используется при вызове `Meteor.clearInterval`.

{{> api_box clearTimeout}}
{{> api_box clearInterval}}

<h2 id="deps"><span>Объект Deps</span></h2>
Meteor содержит простую систему отслеживания зависимостей, которая позволяет
автоматически перезапускать реактивные контексты (например, перерисовывать
шаблоны) всякий раз при изменении информации в реактивных источниках данных
(например, значений в объекте [`Session`](#session) или результатов запросов
к БД).

В отличие от большинства других систем, вы не должны указывать эти
зависимости вручную &mdash; все работает само по себе. Алгоритм простой и
эффективный. Когда вы вызываете функцию, поддерживающую реактивные изменения
(например, запрос к базе данных), она автоматически сохраняет текущий
реактивный контекст (в виде экземпляра объекта `Computation`), если, конечно,
он присутствует (например, контекст отрисовки шаблона). Позже, когда данные
изменятся, функция может "инвалидировать" сохраненный контекст, что вызовет
его перезапуск (перерисовку шаблона).

Для приложений будет полезна функция [`Deps.autorun`](#deps_autorun), в то
время как более продвинутые средства, такие как `Deps.Dependency` и колбэки
`onInvalidate`, предназначены больше для создателей пакетов, реализующих
новые реактивные источники данных.

{{> api_box deps_autorun }}

`Deps.autorun` allows you to run a function that depends on reactive data
sources, in such a way that if there are changes to the data later,
the function will be rerun.

For example, you can monitor a cursor (which is a reactive data
source) and aggregate it into a session variable:

    Deps.autorun(function () {
      var oldest = _.max(Monkeys.find().fetch(), function (monkey) {
        return monkey.age;
      });
      if (oldest)
        Session.set("oldest", oldest.name);
    });

Or you can wait for a session variable to have a certain value, and do
something the first time it does, calling `stop` on the computation to
prevent further rerunning:

    Deps.autorun(function (c) {
      if (! Session.equals("shouldAlert", true))
        return;

      c.stop();
      alert("Oh no!");
    });

The function is invoked immediately, at which point it may alert and
stop right away if `shouldAlert` is already true.  If not, the
function is run again when `shouldAlert` becomes true.

A change to a data dependency does not cause an immediate rerun, but
rather "invalidates" the computation, causing it to rerun the next
time a flush occurs.  A flush will occur automatically as soon as
the system is idle if there are invalidated computations.  You can
also use [`Deps.flush`](#deps_flush) to cause an immediate flush of
all pending reruns.

If you nest calls to `Deps.autorun`, then when the outer call stops or
reruns, the inner call will stop automatically.  Subscriptions and
observers are also automatically stopped when used as part of a
computation that is rerun, allowing new ones to be established.  See
[`Meteor.subscribe`](#meteor_subscribe) for more information about
subscriptions and reactivity.

If the initial run of an autorun throws an exception, the computation
is automatically stopped and won't be rerun.

{{> api_box deps_flush }}

Normally, when you make changes (like writing to the database),
their impact (like updating the DOM) is delayed until the system is
idle. This keeps things predictable &mdash; you can know that the DOM
won't go changing out from under your code as it runs. It's also one
of the things that makes Meteor fast.

`Deps.flush` forces all of the pending reactive updates to complete.
For example, if an event handler changes a Session
variable that will cause part of the user interface to rerender, the
handler can call `flush` to perform the rerender immediately and then
access the resulting DOM.

An automatic flush occurs whenever the system is idle which performs
exactly the same work as `Deps.flush`.  The flushing process consists
of rerunning any invalidated computations.  If additional
invalidations happen while flushing, they are processed as part of the
same flush until there is no more work to be done.  Callbacks
registered with [`Deps.afterFlush`](#deps_afterflush) are called
after processing outstanding invalidations.

It is illegal to call `flush` from inside a `flush` or from a running
computation.

{{> api_box deps_nonreactive }}

Calls `func` with `Deps.currentComputation` temporarily set to `null`
and returns `func`'s own return value.  If `func` accesses reactive data
sources, these data sources will never cause a rerun of the enclosing
computation.

{{> api_box deps_active }}

This value is useful for data source implementations to determine
whether they are being accessed reactively or not.

{{> api_box deps_currentcomputation }}

It's very rare to need to access `currentComputation` directly.  The
current computation is used implicitly by
[`Deps.active`](#deps_active) (which tests whether there is one),
[`dependency.depend()`](#dependency_depend) (which registers that it depends on a
dependency), and [`Deps.onInvalidate`](#deps_oninvalidate) (which
registers a callback with it).

{{> api_box deps_oninvalidate }}

See [*`computation`*`.onInvalidate`](#computation_oninvalidate) for more
details.

{{> api_box deps_afterflush }}

Functions scheduled by multiple calls to `afterFlush` are guaranteed
to run in the order that `afterFlush` was called.  Functions are
guaranteed to be called at a time when there are no invalidated
computations that need rerunning.  This means that if an `afterFlush`
function invalidates a computation, that computation will be rerun
before any other `afterFlush` functions are called.

<h2 id="deps_computation"><span>Deps.Computation</span></h2>

A Computation object represents code that is repeatedly rerun in
response to reactive data changes.  Computations don't have return
values; they just perform actions, such as rerendering a template on
the screen.  Computations are created using [`Deps.autorun`](#deps_autorun).
Use [`stop`](#computation_stop) to prevent further rerunning of a
computation.

Each time a computation runs, it may access various reactive data
sources that serve as inputs to the computation, which are called its
dependencies.  At some future time, one of these dependencies may
trigger the computation to be rerun by invalidating it.  When this
happens, the dependencies are cleared, and the computation is
scheduled to be rerun at flush time.

The *current computation*
([`Deps.currentComputation`](#deps_currentcomputation)) is the
computation that is currently being run or rerun (computed), and the
one that gains a dependency when a reactive data source is accessed.
Data sources are responsible for tracking these dependencies using
[`Deps.Dependency`](#deps_dependency) objects.

Invalidating a computation sets its `invalidated` property to true
and immediately calls all of the computation's `onInvalidate`
callbacks.  When a flush occurs, if the computation has been invalidated
and not stopped, then the computation is rerun by setting the
`invalidated` property to `false` and calling the original function
that was passed to `Deps.autorun`.  A flush will occur when the current
code finishes running, or sooner if `Deps.flush` is called.

Stopping a computation invalidates it (if it is valid) for the purpose
of calling callbacks, but ensures that it will never be rerun.

Example:

    // if we're in a computation, then perform some clean-up
    // when the current computation is invalidated (rerun or
    // stopped)
    if (Deps.active) {
      Deps.onInvalidate(function () {
        x.destroy();
        y.finalize();
      });
    }

{{> api_box computation_stop}}

Stopping a computation is irreversible and guarantees that it will
never be rerun.  You can stop a computation at any time, including
from the computation's own run function.  Stopping a computation that
is already stopped has no effect.

Stopping a computation causes its `onInvalidate` callbacks to run
immediately if it is not currently invalidated.

Nested computations are stopped automatically when their enclosing
computation is rerun.

{{> api_box computation_invalidate }}

Invalidating a computation marks it to be rerun at
[flush time](#deps_flush), at
which point the computation becomes valid again.  It is rare to
invalidate a computation manually, because reactive data sources
invalidate their calling computations when they change.  Reactive data
sources in turn perform this invalidation using one or more
[`Deps.Dependency`](#deps_dependency) objects.

Invalidating a computation immediately calls all `onInvalidate`
callbacks registered on it.  Invalidating a computation that is
currently invalidated or is stopped has no effect.  A computation can
invalidate itself, but if it continues to do so indefinitely, the
result will be an infinite loop.

{{> api_box computation_oninvalidate }}

`onInvalidate` registers a one-time callback that either fires
immediately or as soon as the computation is next invalidated or
stopped.  It is used by reactive data sources to clean up resources or
break dependencies when a computation is rerun or stopped.

To get a callback after a computation has been recomputed, you can
call [`Deps.afterFlush`](#deps_afterflush) from `onInvalidate`.

{{> api_box computation_stopped }}

{{> api_box computation_invalidated }}

This property is initially false.  It is set to true by `stop()` and
`invalidate()`.  It is reset to false when the computation is
recomputed at flush time.

{{> api_box computation_firstrun }}

This property is a convenience to support the common pattern where a
computation has logic specific to the first run.

<h2 id="deps_dependency"><span>Deps.Dependency</span></h2>

A Dependency represents an atomic unit of reactive data that a
computation might depend on.  Reactive data sources such as Session or
Minimongo internally create different Dependency objects for different
pieces of data, each of which may be depended on by multiple
computations.  When the data changes, the computations are
invalidated.

Dependencies don't store data, they just track the set of computations to
invalidate if something changes.  Typically, a data value will be
accompanied by a Dependency object that tracks the computations that depend
on it, as in this example:

    var weather = "sunny";
    var weatherDep = new Deps.Dependency;

    var getWeather = function () {
      weatherDep.depend()
      return weather;
    };

    var setWeather = function (w) {
      weather = w;
      // (could add logic here to only call changed()
      // if the new value is different from the old)
      weatherDep.changed();
    };

This example implements a weather data source with a simple getter and
setter.  The getter records that the current computation depends on
the `weatherDep` dependency using `depend()`, while the setter
signals the dependency to invalidate all dependent computations by
calling `changed()`.

The reason Dependencies do not store data themselves is that it can be
useful to associate multiple Dependencies with the same piece of data.
For example, one Dependency might represent the result of a database
query, while another might represent just the number of documents in
the result.  A Dependency could represent whether the weather is sunny
or not, or whether the temperature is above freezing.
[`Session.equals`](#session_equals) is implemented this way for
efficiency.  When you call `Session.equals("weather", "sunny")`, the
current computation is made to depend on an internal Dependency that
does not change if the weather goes from, say, "rainy" to "cloudy".

Conceptually, the only two things a Dependency can do are gain a
dependent and change.

A Dependency's dependent computations are always valid (they have
`invalidated === false`).  If a dependent is invalidated at any time,
either by the Dependency itself or some other way, it is immediately
removed.

{{> api_box dependency_changed }}

{{> api_box dependency_depend }}

`dep.depend()` is used in reactive data source implementations to record
the fact that `dep` is being accessed from the current computation.

{{> api_box dependency_hasdependents }}

For reactive data sources that create many internal Dependencies,
this function is useful to determine whether a particular Dependency is
still tracking any dependency relationships or if it can be cleaned up
to save memory.

<h2 id="ejson"><span>EJSON</span></h2>

EJSON is an extension of JSON to support more types. It supports all JSON-safe
types, as well as:

 - **Date** (JavaScript `Date`)
 - **Binary** (JavaScript `Uint8Array` or the
   result of [`EJSON.newBinary`](#ejson_new_binary))
 - **User-defined types** (see [`EJSON.addType`](#ejson_add_type).  For example,
 [`Meteor.Collection.ObjectID`](#collection_object_id) is implemented this way.)

All EJSON serializations are also valid JSON.  For example an object with a date
and a binary buffer would be serialized in EJSON as:

    {
      "d": {"$date": 1358205756553},
      "b": {"$binary": "c3VyZS4="}
    }

Meteor supports all built-in EJSON data types in publishers, method arguments
and results, Mongo databases, and [`Session`](#session) variables.

{{> api_box ejsonParse}}

{{> api_box ejsonStringify}}

{{> api_box ejsonFromJSONValue}}

{{> api_box ejsonToJSONValue}}

{{> api_box ejsonEquals}}

{{> api_box ejsonClone}}

{{> api_box ejsonNewBinary}}

Buffers of binary data are represented by `Uint8Array` instances on JavaScript
platforms that support them.  On implementations of JavaScript that do not
support `Uint8Array`, binary data buffers are represented by standard arrays
containing numbers ranging from 0 to 255, and the `$Uint8ArrayPolyfill` key
set to `true`.

{{> api_box ejsonIsBinary}}

{{> api_box ejsonAddType}}

When you add a type to EJSON, Meteor will be able to use that type in:

 - publishing objects of your type if you pass them to publish handlers.
 - allowing your type in the return values or arguments to
   [methods](#methods_header).
 - storing your type client-side in Minimongo.
 - allowing your type in [`Session`](#session) variables.

{{#note}}

  MongoDB cannot store most user-defined types natively on the server.  Your
  type will work in Minimongo, and you can send it to the client using a custom
  publisher, but MongoDB can only store the types defined in
  [BSON](http://bsonspec.org/).

{{/note}}

Instances of your type must implement [`typeName`](#ejson_type_typeName) and
[`toJSONValue`](#ejson_type_toJSONValue) methods, and may implement
[`clone`](#ejson_type_clone) and [`equals`](#ejson_type_equals) methods if the
default implementations are not sufficient.

{{> api_box ejsonTypeName}}
{{> api_box ejsonTypeToJSONValue}}

For example, the `toJSONValue` method for
[`Meteor.Collection.ObjectID`](#collection_object_id) could be:

    function () {
      return this.toHexString();
    };

{{> api_box ejsonTypeClone}}

If your type does not have a `clone` method, `EJSON.clone` will use
[`toJSONValue`](#ejson_type_toJSONValue) and the factory instead.

{{> api_box ejsonTypeEquals}}

The `equals` method should define an [equivalence
relation](http://en.wikipedia.org/wiki/Equivalence_relation).  It should have
the following properties:

 - *Reflexivity* - for any instance `a`: `a.equals(a)` must be true.
 - *Symmetry* - for any two instances `a` and `b`: `a.equals(b)` if and only if `b.equals(a)`.
 - *Transitivity* - for any three instances `a`, `b`, and `c`: `a.equals(b)` and `b.equals(c)` implies `a.equals(c)`.

If your type does not have an `equals` method, `EJSON.equals` will compare the
result of calling [`toJSONValue`](#ejson_type_toJSONValue) instead.


<h2 id="http"><span>HTTP</span></h2>

`HTTP` provides an HTTP request API on the client and server.  To use
these functions, add the HTTP package to your project with `$ meteor add http`.

{{> api_box httpcall}}

This function initiates an HTTP request to a remote server.

On the server, this function can be run either synchronously or
asynchronously.  If the callback is omitted, it runs synchronously
and the results are returned once the request completes successfully.
If the request was not successful, an error is thrown.
This is
useful when making server-to-server HTTP API calls from within Meteor
methods, as the method can succeed or fail based on the results of the
synchronous HTTP call.  In this case, consider using
[`this.unblock()`](#method_unblock) to allow other methods on the same
connection to run in
the mean time.  On the client, this function must be used
asynchronously by passing a callback.

Both HTTP and HTTPS protocols are supported.  The `url` argument must be
an absolute URL including protocol and host name on the server, but may be
relative to the current host on the client.  The `query` option
replaces the query string of `url`.  Parameters specified in `params`
that are put in the URL are appended to any query string.
For example, with a `url` of `"/path?query"` and
`params` of `{foo:"bar"}`, the final URL will be `"/path?query&foo=bar"`.

The `params` are put in the URL or the request body, depending on the
type of request.  In the case of request with no bodies, like GET and
HEAD, the parameters will always go in the URL.  For a POST or other
type of request, the parameters will be encoded into the body with a
standard `x-www-form-urlencoded` content type, unless the `content`
or `data` option is used to specify a body, in which case the
parameters will be appended to the URL instead.

When run in asynchronous mode, the callback receives two arguments,
`error` and `result`.  The
`error` argument will contain an Error if the request fails in any
way, including a network error, time-out, or an HTTP status code in
the 400 or 500 range.  In case of a 4xx/5xx HTTP status code, the
`response` property on `error` matches the contents of the result
object.  When run in synchronous mode, either `result` is returned
from the function, or `error` is thrown.

Contents of the result object:

<dl class="objdesc">

<dt><span class="name">statusCode</span>
  <span class="type">Number</span></dt>
<dd>Numeric HTTP result status code, or <code>null</code> on error.</dd>

<dt><span class="name">content</span>
  <span class="type">String</span></dt>
<dd>The body of the HTTP response as a string.</dd>

<dt><span class="name">data</span>
  <span class="type">Object or <code>null</code></span></dt>
<dd>If the response headers indicate JSON content, this contains the body of the document parsed as a JSON object.</dd>

<dt><span class="name">headers</span>
  <span class="type">Object</span></dt>
<dd>A dictionary of HTTP headers from the response.</dd>

</dl>

Example server method:

    Meteor.methods({checkTwitter: function (userId) {
      check(userId, String);
      this.unblock();
      try {
        var result = HTTP.call("GET", "http://api.twitter.com/xyz",
                               {params: {user: userId}});
        return true;
      } catch (e) {
        // Got a network error, time-out or HTTP error in the 400 or 500 range.
        return false;
      }
    }});

Example asynchronous HTTP call:

    HTTP.call("POST", "http://api.twitter.com/xyz",
              {data: {some: "json", stuff: 1}},
              function (error, result) {
                if (!error) {
                  Session.set("twizzled", true);
                }
              });


{{> api_box http_get}}
{{> api_box http_post}}
{{> api_box http_put}}
{{> api_box http_del}}


<h2 id="email"><span>Email</span></h2>

The `email` package allows sending email from a Meteor app. To use it, add the
package to your project with `$ meteor add email`.

The server reads from the `MAIL_URL` environment variable to determine how to
send mail. Currently, Meteor supports sending mail over SMTP; the `MAIL_URL`
environment variable should be of the form
`smtp://USERNAME:PASSWORD@HOST:PORT/`. For apps deployed with `meteor deploy`,
`MAIL_URL` defaults to an account (provided by
[Mailgun](http://www.mailgun.com/)) which allows apps to send up to 200 emails
per day; you may override this default by assigning to `process.env.MAIL_URL`
before your first call to `Email.send`.

If `MAIL_URL` is not set (eg, when running your application locally),
`Email.send` outputs the message to standard output instead.

{{> api_box email_send }}

You must provide the `from` option and at least one of `to`, `cc`, and `bcc`;
all other options are optional.

`Email.send` only works on the server. Here is an example of how a
client could use a server method call to send an email. (In an actual
application, you'd need to be careful to limit the emails that a
client could send, to prevent your server from being used as a relay
by spammers.)

    // In your server code: define a method that the client can call
    Meteor.methods({
      sendEmail: function (to, from, subject, text) {
        check([to, from, subject, text], [String]);

        // Let other method calls from the same client start running,
        // without waiting for the email sending to complete.
        this.unblock();

        Email.send({
          to: to,
          from: from,
          subject: subject,
          text: text
        });
      }
    });

    // In your client code: asynchronously send an email
    Meteor.call('sendEmail',
                'alice@example.com',
                'bob@example.com',
                'Hello from Meteor!',
                'This is a test of Email.send.');

{{/markdown}}

<h2 id="assets"><span>Assets</span></h2>

{{#markdown}}
`Assets` allows server code in a Meteor application to access static server
assets, which are located in the `private` subdirectory of an application's
tree.

{{> api_box assets_getText }}
{{> api_box assets_getBinary }}

Static server assets are included by placing them in the application's `private`
subdirectory. For example, if an application's `private` subdirectory includes a
directory called `nested` with a file called `data.txt` inside it, then server
code can read `data.txt` by running:

    var data = Assets.getText('nested/data.txt');
{{/markdown}}

</template>






<template name="api_box">
<div class="api {{bare}}">

<h3 id="{{id}}">
  <a class="name selflink" href="#{{id}}">{{{name}}}</a>
{{#if locus}}
  <span class="locus">{{locus}}</span>
{{/if}}
</h3>

<div class="desc">
{{#each descr}}{{#markdown}}{{{this}}}{{/markdown}}{{/each}}
</div>

{{#if args}}
<h4>Аргументы</h4>
{{> api_box_args args}}
{{/if}}

{{#if options}}
<h4>Опции</h4>
{{> api_box_args options}}
{{/if}}

{{#if UI.contentBlock}}
{{#markdown}}{{> UI.contentBlock}}{{/markdown}}
{{/if}}

</div>

</template>



<template name="api_box_args">
<dl class="args">
{{#each this}}
<dt><span class="name">{{{name}}}</span>
  <span class="type">
    {{#if type_link}}
      <a href="#{{type_link}}">{{{type}}}</a>
    {{else}}
      {{{type}}}
    {{/if}}
  </span></dt>
<dd>{{#markdown}}{{{descr}}}{{/markdown}}</dd>
{{/each}}
</dl>
</template>


<template name="api_section">
<h2 id="{{id}}"><a href="#{{id}}" class="selflink"><span>{{name}}</span></a></h2>
</template>
