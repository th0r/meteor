<template name="concepts">

<h1 id="concepts">Концепции</h1>

Мы написали большое количество одностраничных приложений на JavaScript вручную.
Написание всего приложения на одном языке (JavaScript), используя один формат данных
(JSON) - это сказка. И все, что нам тогда было нужно для их написания - это Meteor.

{{> whatismeteor }}
{{> structure }}
{{> data }}
{{> reactivity }}
{{> livehtmltemplates }}
{{> packages_concept }}
{{> namespacing }}
{{> deploying }}
{{> packages_writing }}
</template>

<template name="whatismeteor">

{{#markdown}}

<h2 id="whatismeteor">Что такое Meteor?</h2>

Meteor - это две вещи:

* _Библиотека пакетов_: заранее написанные независимые модули, которые
могут вам понадобиться в вашем приложении.<br>
Ядро Meteor состоит примерно из дюжины таких пакетов, которые будут
использоваться в большинстве приложений (например пакет `webapp`, который
обрабатывает входящие HTTP-подключения, и `templating`, который позволяет
писать HTML-шаблоны, автоматически обновляемые при изменении данных).
Также существуют дополнительные пакеты, например `email`, который позволяет
вашему приложению посылать email-ы, или серия пакетов Meteor Accounts (`account-password`,
`accounts-facebook`, `accounts-ui` и другие) которые предоставляют полноценную
систему учетных записей для вашего приложения. И помимо этих "официальных" пакетов,
в [Atmosphere](https://atmosphere.meteor.com/) присутствуют сотни других, написанных
сообществом, и один из них, возможно, делает именно то, что вам необходимо.

* _Утилита командной строки_ `meteor`.<br>
`meteor` - это утилита для сборки, аналогичная `make`, `rake`, или 
без-интерфейсным частям Visual Studio. Она собирает воедино все исходники и
статику вашего приложения, выполняет все необходимые шаги сборки (такие, как
компилирование [CoffeeScript](http://coffeescript.org), минификация CSS,
сборка [npm](https://npmjs.org/)-модулей и генерация source maps), загружает 
все модули, используемые в вашем приложении и создает из него автономный 
пакет, готовый к использованию. В режиме разработки она делает все это "на 
лету", т.е. каждый раз, когда вы вносите какие-либо изменения в файл, вы
сразу же видите это в браузере. Она очень простая в использовании и к тому же
легко расширяемая: вы можете добавить поддержку дополнительных языков и 
компиляторов, просто добавив в ваше приложение дополнительные пакеты для сборки.

Основная идея пакетной системы Meteor состоит в том, что _все должно работать
одинакого как в браузере, так и на сервере_ (конечно, если это имеет смысл: 
браузеры не умеют посылать email-ы, а серверы - ловить события мышки). Вся 
наша экосистема была построена с нуля, чтобы обеспечить работоспособность 
данного подхода.

{{#note}}
Утилита `meteor` пока не умеет загружать пакеты из Atmosphere. Если же вы
хотите их использовать, то вам следует взглянуть на 
[Meteorite](http://oortcloud.github.io/meteorite/) - эта утилита поможет вам 
с загрузкой и управлением пакетами из Atmosphere.

В Meteor 1.0 утилита `meteor` будет полностью поддерживать Atmosphere.
{{/note}}

{{/markdown}}
</template>

<template name="structure">
{{#markdown}}

<h2 id="structuringyourapp">Структура приложения</h2>

Приложение на Meteor - это смесь клиентского JavaScript, который работает в
браузере, серверного JavaScript, который работает под управлением
[Node.js](http://nodejs.org/) и всех поддерживаемых форматов HTML, CSS и 
других статичных ресурсов. Meteor автоматизирует упаковку и передачу всех этих 
компонентов и позволяет вам иметь довольно гибкую структуру файлов в
директории вашего приложения.

Единственными статическими ресурсами со стороны сервера являются 
JavaScript-файлы и файлы из поддиректории `private`. Meteor собирает все 
JavaScript-файлы, кроме тех, которые находятся в поддиректориях `client`, 
`public` и `private`, и загружает их в экземпляр Node.js-сервера, используя 
волокна (fibers). Ваш серверный код в Meteor работает в режиме "один поток на
один запрос", а не в привычном для Node режиме асинхронных обратных вызовов 
(callbacks). Мы считаем, что линейная модель исполнения лучше подходит 
для типичного серверного кода приложения на Meteor.

Meteor собирает все файлы из поддиректории `private` и предоставляет доступ к
их содержимому при помощи [`Assets`](#assets) API. Поддиректория `private` 
предназначена для хранения любых файлов, которые должны быть доступны 
серверному коду, но недоступны клиентскому. Например, файлов с 
конфиденциальной информацией.

На клиенте статичных ресурсов побольше. Для него Meteor собирает все
JavaScript-файлы из директории вашего приложения за исключением тех,
которые находятся в поддиректориях `server`, `public` и `private`. Он 
минифицирует получившийся пакет и раздает его каждому клиенту. Таким образом вы
можете либо написать ваше приложение в одном JavaScript-файле, либо же
создать вложенное дерево с множеством отдельных файлов.

Некоторые JavaScript-библиотеки работают только если их поместить в 
поддиректорию `client/compatibility`. У данных файлов не меняется область 
действия переменных, т.е. каждая внешняя переменная, объявленная через `var`,
создает глобальную переменную. К тому же, эти файлы на клиенте выполняются 
самыми первыми.

Файлы, находящиеся вне директорий `client`, `server` и `tests`, загружаются 
как на клиентe, так и на серверe! Это самое место для объявления моделей и 
разных общих функций. У объекта Meteor есть свойства 
[`isClient`](#meteor_isclient) и [`isServer`](#meteor_isserver), используя 
которые вы можете определить, где сейчас выполняется ваш код - на клиенте, 
или на сервере. (Файлы из директорий `tests` никуда не загружаются.)

Любой конфиденциальный код, который не должен попасть на клиент (например, 
код, содержащий пароли или механизмы аутентификации), необходимо хранить в 
директории `server`.

CSS файлы из всех поддиректорий проекта, кроме `server`, `public` и 
`private`, также собираются в один пакет и отправляются на клиент.

В режиме разработки, JavaScript и CSS-файлы отсылаются на клиент не в виде 
пакета, а как индивидуальные файлы. Сделано это для того, чтобы облегчить 
отладку приложения.

HTML-файлы Meteor обрабатывает несколько иначе, чем остальные фреймворки. 
Meteor сканирует все HTML-файлы в поисках трех элементов верхнего
уровня: `<head>`, `<body>` и `<template>`. Все секции `head` и `body` 
объединяются и передаются на клиент при первоначальной загрузке страницы.

Секции `template` же преобразуются в JavaScript-функции и сохраняются в 
объекте `Template` - это очень удобный способ передачи HTML-шаблонов на 
клиент. Более подробно об этом можно узнать в разделе ["Шаблоны"](#livehtmltemplates).

И наконец, Meteor будет раздавать любые файлы, находящиеся в директории 
`public` точно так же, как это делают, например, Django или Rails. Там 
следует хранить изображения, `favicon.ico`, `robots.txt` и прочую статику.

Лучше всего стараться писать ваше приложение таким образом, чтобы оно не 
зависило он порядка загрузки файлов. Для этого можно использовать функцию 
[Meteor.startup](#meteor_startup), или помещать код, зависящий от порядка 
загрузки, в [пакеты](#usingpackages), которые позволяют явно указать не только 
порядок загрузки их частей, но и их зависимости от других пакетов. Несмотря 
на это бывают ситуации, когда порядок загрузки файлов важен. Для решения 
таких проблем существует несколько правил, по которым ваше приложение 
загружает JavaScript и CSS:

* Файлы из поддиректорий загружаются раньше файлов, находящихся в
  родительских директориях. Таким образом файлы из самой глубокой
  поддиректории загружаются первыми, а файлы из корневой директории - последними.

* В пределах одной директории файлы загружаются в алфавитном порядке по их
  названию.
  
* После вышеуказанной сортировки, все файлы из директорий `lib` перемещаются
  в самое начало списка, сохраняя при этом свой порядок.
  
* И в завершение, все файлы с именами `main.*` перемещаются в конец списка,
  сохраняя свой порядок.

{{/markdown}}
</template>

<template name="data">
{{#markdown}}

<h2 id="dataandsecurity">Данные и безопасность</h2>

Общаться с локальной базой данных в Meteor так же просто, как и писать 
клиентский код. Это простой, понятный и безопасный подход, который устраняет 
необходимость создавать индивидуальные конечные точки RPC, вручную кешировать
данные на клиенте, чтобы не ждать долгих ответов от сервера и аккуратно 
оповещать клиентов о том, что данные на сервере изменились.

Клиент и сервер в Meteor используют одинаковое API для работы с базой данных.
Таким образом, один и тот же код, например, валидаторы или 
вычисляемые свойства, обычно можно использовать в обоих местах. Но если у 
серверного кода есть прямой доступ к базе данных, то у клиент его *нет*.
И это отличие - основа модели безопасности данных в Metor.

{{#note}}
Каждое новое приложение по умолчанию использует пакеты `autopublish` и 
`insecure`, которые в сочетании друг с другом создают эффект присутствия у 
каждого клиента полного доступа к базе данных сервера на чтение и запись. Эти
пакеты бывают довольно удобны при разработке приложения, но, как
правило, не подходят для подакшена. Так что, просто удалите из, как только вы
будете готовы.
{{/note}}

Каждый клиент в Meteor содержит кэш базы данных и хранит его в памяти. 
Управление его содержимым происходит следующим образом: сервер *публикует* 
некоторые наборы JSON-документов, а клиент *подписывается* на них. Как только
документы из набора меняются, сервер обновляет (патчит) клиентский кеш.

В настощее время большиство приложений на Meteor в качестве базы данных 
используют MongoDB, потому что она поддерживается лучше всего, но на будущее 
запланирована поддержка и других баз данных. Для объявления Mongo-коллекций и
работы с ними используется класс
[`Meteor.Collection`](http://docs.meteor.com/#meteor_collection). Благодаря 
`minimongo` (эмулятору Mongo на клиенте), его можно использовать как на 
сервере, так и на клиенте.

    // создание коллекций
    // этот код должен быть объявлен как на сервере, так и на клиенте
    Rooms = new Meteor.Collection("rooms");
    Messages = new Meteor.Collection("messages");
    Parties = new Meteor.Collection("parties");

    // сервер: наполнение коллекций несколькими начальными документами
    Rooms.insert({name: "Conference Room A"});
    var myRooms = Rooms.find({}).fetch();
    Messages.insert({text: "Hello world", room: myRooms[0]._id});
    Parties.insert({name: "Super Bowl Party"});

Каждый набор документов определяется функцией публикации на сервере. Она 
вызывается каждый раз, когда клиент подписывается на этот набор. Данные для 
него могут браться откуда угодно, но самый распространенный вариант - это 
публиковать результаты запроса к базе данных.

    // сервер: опубликовать информацию о всех чатах
    Meteor.publish("all-rooms", function () {
      return Rooms.find(); // everything
    });

    // сервер: опубликовать все сообщения из конкретного чата
    Meteor.publish("messages", function (roomId) {
      check(roomId, String);
      return Messages.find({room: roomId});
    });

    // сервер: опубликовать набор групп, которые может видеть залогиненный
    пользователь
    Meteor.publish("parties", function () {
      return Parties.find({$or: [{"public": true},
                                 {invited: this.userId},
                                 {owner: this.userId}]});
    });

Функции публикации могут отдавать разным клиентам разные результаты. В 
предыдущем примере, залогиненный пользователь может видеть только публичные 
группы, созданные им группы и группы, в которые его пригласили.

Как только клиент подписался на публикацию, он использует свой кэш в качестве 
быстрой локальной базы данных, что значительно упрощает клиентский код. Для 
чтения данных оттуда не нужны накладные обращения к серверу. К тому же, 
результаты запросов к локальной базе данных всегда ограничены набором
документов, которые сервер решил опубликовать для данного клиента.

    // клиент: начать подписку на группы
    Meteor.subscribe("parties");

    // клиент: получить массив групп, доступных данному пользователю
    return Parties.find().fetch(); // синхронно!

Продвинутый клиентский код может подписываться на публикации и отписываться от
них, тем самым контролируя объем данных, хранящихся в локальном кэше, и 
управляя сетевым трафиком. Когда подписка прекращена, все ее документы 
удаляются из кэша, если только они не входят в состав какой-либо другой
активной подписки.

Когда клиент *изменяет* один или несколько документов, он посылает сообщение 
серверу с запросом на это изменение. Сервер проверяет данное изменение, 
используя набор разрешающих и запрещающих правил, которые представляют собой 
обычные JavaScript функции. Если все правила пройдены успешно, то сервер 
разрешает данное изменение.

    // сервер: не разрешать клиенту добавлять группу
    Parties.allow({
      insert: function (userId, party) {
        return false;
      }
    });

    // клиент: группа не будет добавлена
    var party = { ... };
    Parties.insert(party);

Если сервер разрешает изменение, он вносит его в базу данных и автоматически
рассылает его всем остальным клиентам, подписанным на измененные документы. 
Если же не разрешает, то база данных на сервере остается нетронутой и никто 
из остальных клиентов этого изменения не видит.

Однако, в Meteor есть одна уловка. Когда клиент хочет записать что-то в базу 
данных и запрашивает разрешение на это у сервера, он не ждет от него ответа, а 
сразу же вносит это изменение в свой локальный кэш. Это означает, что 
интерфейс тут же перерисуется и если сервер примет данное изменение (а в 
правильно работающем клиенте это должно происходить почти всегда), то он 
будет уже в актуальном состоянии. Если же сервер отклонит это изменение, то 
Meteor откатит состояние локального кэша до исходного.

В итоге, все эти методы и обеспечивают компенсацию задержек: клиенты хранят 
локально свежую копию необходимых им данных и им не нужно ждать ответа от 
сервера. Таким образом, когда клиенту нужно изменить какие либо данные, он может 
сделать это локально, не дожидаясь подтверждения сервера, но в то же время 
оставляя за ним решающее слово касательно возможности этих изменений.

{{#note}}
Текущая версия Meteor поддерживает MongoDB - популярную
документо-ориентированную базу данных, а примеры в этом разделе используют 
[MongoDB API](http://www.mongodb.org/display/DOCS/Manual). Поддержка других 
баз данных появится в будущих версиях.
{{/note}}

<h3 id="dataandsecurity-authentication">Аутентификация и учетные записи 
пользователей</h3>

Meteor включает в себя передовую систему аутентификации - [Meteor
Accounts](#accounts_api). Она предоставляет возможность логина с 
использованием пароля, защищенного по протоколу [Secure Remote 
Password](http://en.wikipedia.org/wiki/Secure_Remote_Password_protocol), а 
также интеграцию с внешними сервисами, включая Facebook, GitHub,
Google, Meetup, Twitter и Weibo. Meteor Accounts создает коллекцию 
[`Meteor.users`](#meteor_users), где разработчики приложения могут хранить 
разнообразные данные о пользователях.

Meteor также содержит готовые формы для таких частых действий, как логин, 
регистрация, смена и сброс пароля. Пакет с этими формами называется [Accounts
UI](#accountsui). Чтобы добавить его в ваше приложение, нужно написать всего
одну строчку кода. В состав этого пакета входит даже визард для настройки 
внешних сервисов, поддержку которых вы хотите добавить в ваше приложение.

<h3 id="dataandsecurity-validation">Проверка входных данных</h3>

Meteor позволяет вашим методам и публикациям принимать параметры любого типа,
поддерживаемого форматом [JSON](http://json.org/). (На самом 
деле сетевой протокол Meteor поддерживает [EJSON](#ejson) - расширение JSON, 
которое также поддерживает другие базовые типы данных, такие как даты и 
двоичные буферы). Динамическое типизирование, используемое в JavaScript, 
означает, что вам не нужно указывать тип каждой переменной в вашем 
приложении, но как правило бывает очень удобно удостовериться, что аргументы,
переданные пользователем в ваши методы и публикации, имеют именно тот тип, 
который вы ожидаете.

Meteor включает в себя [маленькую библиотеку](#match) для проверки типа и 
структуры переменных. Просто начинайте ваши функции с таких выражений, как 
`check(username, String)`, или `check(office, {building: String, room: 
Number})`. Функция `check` выдаст ошибку, если ее аргумент не будет нужного 
вам типа.

Meteor также предоставляет легкий способ убедиться в том, что все ваши методы 
и публикации проверяют все свои параметры. Просто выполните команду 
<code>meteor add [audit-argument-checks](#auditargumentchecks)</code> и любой
метод или публикация, которая не проверяет свои аргументы, используя функцию 
`check`, завершится с исключением.

{{/markdown}}
</template>

<template name="reactivity">
{{#markdown}}

<h2 id="reactivity">Реактивность</h2>

Meteor реализует концепцию реактивного программирования ([reactive 
programming](http://en.wikipedia.org/wiki/Reactive_programming)). Это 
означает, что вы можете писать свой код в простом императивном стиле и 
результат будет автоматически пересчитан как только изменятся данные, от 
которых ваш код зависит.

    Deps.autorun(function () {
      Meteor.subscribe("messages", Session.get("currentRoomId"));
    });

Этот код, взятый из примера создания чат-клиента, подписывается на данные, 
используя значение переменной сессии `currentRoomId`. Если значение выражения
`Session.get("currentRoomId")` по каким-либо причинам изменится, функция 
автоматически перевыполнится и подпишется на новый набор документов, 
предварительно отписавшись от предыдущего.

Это автоматическое перевыполнение достигается благодаря совместному 
использованию `Session` и `Deps.autorun`. `Deps.autorun` выполняет 
произвольное "реактивное вычисление", отслеживая все данные, от которого оно 
зависит, и перезапускает его в случае необходимости. С другой стороны, 
источники данных, такие как `Session`, запоминают реактивное вычисление, из 
которого они вызываются, и запрошенные у них данные, чтобы послать вычислению
инвалидирующий сигнал как только эти данные изменятся.

Этот простой паттерн (реактивые вычисления + реактивные источники данных) 
имеет широкое применение. В примере выше, программист избавляется от 
необходимости писать код для своевременной отписки от публикации и
переподписки на нее. В целом, Meteor может устранить целые классы кода, 
предназначенного для распространения данных, которые иначе могли бы засорить 
ваше приложение ненадежной логикой.

Эти функции в Meteor выполняют ваш код в реактивном контексте:

* [Шаблоны](#livehtmltemplates)
* [`Deps.autorun`](#deps_autorun)
* [`UI.render`](#ui_render) и [`UI.renderWithData`](#ui_renderwithdata)

А вот список реактивных источников данных:

* Переменные сессии ([`Session`](#session))
* Запросы к базе данных через [коллекции](#find)
* [`Meteor.status`](#meteor_status)
* Метод `ready()` у [хэндлера подписки](#meteor_subscribe)
* [`Meteor.user`](#meteor_user)
* [`Meteor.userId`](#meteor_userid)
* [`Meteor.loggingIn`](#meteor_loggingin)

К тому же, если следующие функции, возвращающие объект с методом `stop`, 
вызываются в реактивном контексте, то они останавливаются, когда реактивное 
вычисление перезапускается или останавливается:

* [`Deps.autorun`](#deps_autorun) (вложенные вызовы)
* [`Meteor.subscribe`](#meteor_subscribe)
* [`observe()`](#observe) и [`observeChanges()`](#observe_changes) у курсоров

В Meteor реактивность 
[реализована](https://github.com/meteor/meteor/blob/master/packages/deps/deps.js)
в пакете [`Deps`](#deps), который довольно маленький и простой. С его помощью
вы можете самостоятельно создавать новые реактивные источники данных.

{{/markdown}}
</template>

<template name="livehtmltemplates">
{{#markdown}}

<h2 id="livehtmltemplates">Живые HTML-шаблоны</h2>

HTML-шаблоны занимают важнейшее место в любом веб-приложении. В Meteor 
используется фирменная технология живого обновления страниц под названием Blaze,
которая позволяет вам _реактивно_ рендерить ваши шаблоны. Это означает, что
они будут обновляться автоматически, как только изменятся данные, необходимые
для их отрисовки.

Meteor позволяет с легкостью использовать ваш любимый шаблонизатор вместе с
фирменной технологией живого обновления страниц. Просто пишите шаблоны как
обычно, а Meteor позаботится о том, чтобы они обновлялись в реальном времени.

Meteor поставляется с шаблонизатором
[Spacebars](https://github.com/meteor/meteor/blob/devel/packages/spacebars/README.md),
много почерпнувшим из [Handlebars](http://handlebarsjs.com/). У них похожий
синтаксис, но Spacebars был адаптирован для компиляции реактивных шаблонов.

{{#note}}
  На сегодняшний день Spacebars - это единственный шаблонизатор, поставляемый
  вместе с Meteor, однако наше комьюнити создало пакеты для поддержки и других
  языков, например [Jade](https://atmospherejs.com/package/jade).
{{/note}}

Для объявления шаблона, создайте в вашем проекте файл с расширением `.html`.
В файле создайте тэг `<template>`, положите в него ваш шаблон и задайте ему
имя в атрибуте `name` тэга. Meteor скомпилирует ваш шаблон и отправит его на
клиент, где он будет доступен в качестве функции глобального объекта `Template`.

После загрузки приложения, Meteor автоматически рендерит специальный шаблон
под названием `body`, который объявляется при помощи элемента `<body>` вместо
`<template>`. Для вставки одного шаблона в другой используется оператор
`{{dstache}}> ...}}`, где вместо троеточия должно стоять имя вставляемого
шаблона.

Самый простой способ передать данные в шаблон - это объявить хэлпер-функцию
прямо в объекте шаблона `Template.`*templateName*. Вот простой пример:

    <!-- в myapp.html -->
    <body>
      <h1>Today's weather!</h1>
      {{dstache}}> forecast}}
    </body>

    <template name="forecast">
      <div>It'll be {{dstache}}prediction}} tonight</div>
    {{lt}}/template>

    // в client/myapp.js: реактивная хэлпер-функция
    Template.forecast.prediction = function () {
      return Session.get("weather");
    };

    // в консоли браузера
    > Session.set("weather", "cloudy");
    > document.body.innerHTML
     => "<h1>Today's weather!</h1> <div>It'll be cloudy tonight</div>"

    > Session.set("weather", "cool and dry");
    > document.body.innerHTML
     => "<h1>Today's weather!</h1> <div>It'll be cool and dry tonight</div>"


Для обхода массива или курсора используйте хэлпер `{{dstache}}#each}}`:

    <!-- в myapp.html -->
    <template name="players">
      {{dstache}}#each topScorers}}
        <div>{{dstache}}name}}</div>
      {{dstache}}/each}}
    {{lt}}/template>

    // в myapp.js
    Template.players.topScorers = function () {
      return Users.find({score: {$gt: 100}}, {sort: {score: -1}});
    };

В этом случае информация берется из запроса к базе данных. Когда в
`{{dstache}}#each}}` передается курсор, этот хэлпер использует все доступные
средства для эффективного добавления и перемещения DOM-элементов при изменении
документов в запросе.

Хэлперы могут принимать аргументы, а в `this` они получают текущий контекст
данных для шаблона. Обратите внимание, что некоторые блочные хэдперы (например,
`{{dstache}}#each}}` или `{{dstache}}#with}}`) меняют этот контекст:

    // в JavaScript-файле
    Template.players.leagueIs = function (league) {
      return this.league === league;
    };

    <!-- в HTML-файле -->
    <template name="players">
      {{dstache}}#each topScorers}}
        {{dstache}}#if leagueIs "junior"}}
          <div>Junior: {{dstache}}name}}</div>
        {{dstache}}/if}}
        {{dstache}}#if leagueIs "senior"}}
          <div>Senior: {{dstache}}name}}</div>
        {{dstache}}/if}}
      {{dstache}}/each}}
    {{lt}}/template>

Хэлперы также можно использовать для передачи неизменных данных:

    // Прекрасно работает с {{dstache}}#each sections}}
    Template.report.sections = ["Situation", "Complication", "Resolution"];

И наконец, вы можете указать таблицу обработчиков событий, используя свойство
`events` объекта шаблона. Формат этой таблицы указан в разделе [Карты
событий](#eventmaps). В обработчике события, `this` будет указывать на 
контекст данных того элемента, который это событие вызвал.

    <!-- myapp.html -->
    <template name="scores">
      {{dstache}}#each player}}
        {{dstache}}> playerScore}}
      {{dstache}}/each}}
    {{lt}}/template>

    <template name="playerScore">
      <div>{{dstache}}name}}: {{dstache}}score}}
        <span class="givePoints">Give points</span>
      </div>
    {{lt}}/template>

    <!-- myapp.js -->
    Template.playerScore.events({
      'click .givePoints': function () {
        Users.update(this._id, {$inc: {score: 2}});
      }
    });

Более подробно о Spacebars можно узнать из [Spacebars
README](https://github.com/meteor/meteor/blob/devel/packages/spacebars/README.md).

{{/markdown}}
</template>

<template name="packages_concept">
{{#markdown}}

  <h2 id="usingpackages">Работа с пакетами</h2>

Весь функционал, о котором вы читали до сих пор, реализован в виде 
стандартных Meteor-пакетов. Это возможно благодаря тому, что Meteor обладает 
необычано мощными системами сборки и управления пакетами. Одни и те же пакеты
могут работать как в браузере, так и на сервере, а также могут содержать 
плагины для расширения возможностей системы сборки, например `coffeescript`
(компиляция [CoffeeScript](http://coffeescript.org)) или `templating` 
(компиляция HTML-шаблонов).

Вы можете посмотреть список доступных пакетов с помошью команды
[`meteor list`](#meteorlist), добавлять пакеты в ваш проект с помошью
[`meteor add`](#meteoradd), и удалять их из проекта с помошью
[`meteor remove`](#meteorremove).

По умолчанию, все новые приложения используют пакет `standard-app-packages`. 
Он включает в себя основные пакеты, составляющие ядро Meteor, и необходимые в
большинстве веб-приложений. Для простоты, они не показываются в списке при
использовании команды `meteor list`, но вы можете узнать их состав, заглянув в
[исходники пакета `standard-app-packages`](https://github.com/meteor/meteor/blob/master/packages/standard-app-packages/package.js) 
(так как Meteor еще не достиг версии 1.0, состав этого пакета может меняться 
от версии к версии). Если же для вашего приложения не нужны все базовые 
пакеты из `standard-app-packages`, то просто удалите его и добавьте из него
только нужные.

Команды `meteor list`, `meteor add` и `meteor remove` работают не только с 
официальными пакетами Meteor, но и с пакетами, находящимися в директории 
`packages` в корне вашего приложения. В нее вы и должны распаковывать все 
неофициальные пакеты, скачанные из Atmosphere (неофициальная утилита 
[Meteorite](http://oortcloud.github.io/meteorite/) значительно упрощает этот 
процесс). Также, для удобства, вы можете разбить ваше приложение на пакеты, 
если только вас не смущает тот факт, что формат пакетов в Meteor еще не 
документирован и наверняка сильно изменится до версии 1.0. Подробнее об этом 
можно почитать в разделе [Написание Пакетов](#writingpackages).

{{/markdown}}
</template>


<template name="namespacing">
{{#markdown}}

  <h2 id="namespacing">Пространства имен</h2>

Поддержка пространств имен в Meteor позволяет с легкостью писать на нем большие
приложения. Каждый пакет, используемый в вашем приложении, находится в своем
личном пространстве имен, т.е. ему доступны только глобальные переменные и 
публичные переменные используемых им пакетов. Вот как это все работает.

Когда вы объявляете переменную верхнего уровня, у вас есть выбор: вы можете
сделать ее переменной файла или переменной пакета.

    // Переменная файла. Эта переменная будет видна только в этом файле. Для 
    // других файлов из этого пакета или приложения она будет невидима.
    var alicePerson = {name: "alice"};

    // Переменная пакета. Эта переменная доступна из любого файла пакета и 
    // приложения. Разница в том, что здесь она объявлена без 'var'.
    bobPerson = {name: "bob"};

Обратите внимание, что это обычный способ объявления локальных и глобальных 
переменных в JavaScript. Meteor сканирует исходный код в поисках глобальных 
переменных и генерирует обертку над ним, чтобы эти переменные не покидали 
свое пространство имен.

В добавок к переменным файла и пакета, также существует понятие внешней 
переменной - это переменная, доступная пользователю этого пакета. К примеру, 
пакет `email` объявляет внешнюю переменную `Email`. Если ваше приложение 
использует пакет `email` (и только, если оно его использует _напрямую_), то вам
будет доступна переменная `Email` и вы сможете вызвать метод `Email.send`. 
Большинство пакетов объявляют только одну внешнюю переменную, но некоторые 
могут объявлять и две и три (например, пакет, который создает несколько 
зависящих друг от друга классов).

Вам доступны внешние переменные только тех пакетов, которые вы используете 
напрямую, т.е. если вы используете пакет A, а он в свою очередь использует 
пакет B, то вам будут доступны только внешние переменные пакета A. Внешние 
переменные пакета B не попадают в ваше пространство имен, что делает его 
аккуратным и красивым. Каждое приложение или пакет видит только свои 
глобальные переменные, плюс API необходимых ему пакетов.

Когда вы отлаживаете ваше приложение, браузерная консоль находится в том же 
пространстве имен, что и ваше приложение, т.е. вам доступны только глобальные 
переменные, объявленные в приложении, и внешние переменные явно используемых
им пакетов. Внутренние переменные этих пакетов, а также внешние переменные 
пакетов-зависимостей (пакетов, от которых зависят пакеты, используемые в вашем 
приложении) вам недоступны.

Если же вы хотите заглянуть внутрь пакетов, используя браузерный отладчик, у 
вас есть два варианта:

* Поставить брэйкпоинт в коде пакета. Пока отладчик будет стоять на этом 
  брэйкпоинте, браузерная консоль будет находиться в пространстве имен 
  пакета. Вам будут доступны переменные пакета, внешние переменные его
  пакетов-зависимостей и локальные переменные того файла пакета, в котором вы 
  поставили брэйкпоинт.

* Если пакет `foo` используется в вашем приложении (не важно, явно или нет), 
  его внешние переменные доступны из объекта `Package.foo`. Например, если 
  используется пакет `email`, то вы можете вызвать `Package.email.Email.send`
  даже из пространства имен, в котором он напрямую не используется.

Во время объявления функций учтите, что `function x () {}` - это
просто сокращение для `var x = function () {}`:

    // Это то же самое, что и 'var x = function () ...'. Таким образом 
    // функция x() - это переменная файла и доступна она только из него.
    function x () { ... }

    // Ключевое слово 'var' не указано, поэтому x() - это переменная пакета и
    // доступна из любого файла этого пакета или приложения.
    x = function () { ... }

{{#note}}
С технической точки зрения, глобальные переменные в приложении на самом деле 
являются настоящими глобальными переменными (чего нельзя сказать про 
пакеты). Их нельзя преобразовывать в локальные по отношению к коду приложения, 
т.к. в этом случае они не будут доступны из консоли браузера во время 
отладки! Это означает, что, на самом деле, они видны из кода пакетов, но это 
обстоятельство не должно создавать никаких проблем при правильном их 
написании (так как глобальные переменные в пакетах должным образом 
перекрываются необходимыми объявлениями).
Можно сказать наверняка, что эту особенность пакетов вам использовать не 
стоит, тем более что в будущих версиях Meteor, возможно, в данных ситуациях 
будет выдавать ошибку.
{{/note}}

{{/markdown}}
</template>


<template name="deploying">
{{#markdown}}

<h2 id="deploying">Выкладка</h2>

Meteor - это полноценный сервер для приложений. В нем есть все, что нужно, 
для выкладки вашего приложения в сеть: от вас требуется только
JavaScript, HTML и CSS.

<h3 class="nosection">Выкладка на сервера Meteor</h3>

Самый простой способ выложить ваше приложение - это использовать команду 
`meteor deploy`. Мы предоставляем его, потому что это именно то, что мы 
всегда хотели: легкий способ взять идею для приложения, воплотить ее в жизнь 
за выходные и с легкостью поделиться этим со всем миром, без отрыва от 
творческого процесса.

    $ meteor deploy myapp.meteor.com

Теперь ваше приложение доступно по адресу myapp.meteor.com. Если вы 
выкладываетесь на этот хост впервые, то Meteor создаст для вашего приложения 
свежую пустую базу данных. Если же вы выкладываете обновление, то Meteor 
сохранит существующие данные и просто обновит код.

Вы также можете выложить приложение на свой домен. Просто укажите его в 
качестве `CNAME` к `origin.meteor.com` и выложите на него приложение.

    $ meteor deploy www.myapp.com

Вы предоставляем этот сервис бесплатно. Он также полезен для быстрой выкладки
демок, бета-версий и т.д.

<h3 class="nosection">Выкладка на собственные сервера</h3>

Вы также можете выложить ваше приложение на собственные сервера, либо сервера
любого другого провайдера, например, Heroku.

Для начала, выполните команду

    $ meteor bundle myapp.tgz

Она создаст полноценное приложение на Node.js в виде архива (tarball). Для
запуска этого приложения вам потребуется Node.js 0.10 и сервер MongoDB.
(Текущая версия Meteor была протестирована под Node 0.10.26; предыдущие 
версии содержат серьезный баг, который может привести к зависанию боевых 
серверов). После этого вы можете запустить приложение с помощью node, указав
HTTP-порт и URI доступа к MongoDB. Если у вас еще нет сервера MongoDB,
то мы можем порекомендовать вам наших друзей из [MongoHQ](http://mongohq.com).

    $ PORT=3000 MONGO_URL=mongodb://localhost:27017/myapp node bundle/main.js

Для каких-то пакетов могут потребоваться дополнительные переменные окружения
(например, для пакета `email` нужна переменная `MAIL_URL`).

{{#warning}}
Пока упакованное приложение работает только на той платформе, на которой оно
собиралось. Чтобы запустить его на другой платформе, вам нужно пересобрать
нативные пакеты, входящие в состав приложения. Чтобы это сделать, выполните
следующую команду (у вас должен быть установлен `npm`):

    $ cd bundle/programs/server/node_modules
    $ rm -r fibers
    $ npm install fibers@1.0.1
{{/warning}}

{{/markdown}}
</template>


<template name="packages_writing">
{{#markdown}}

  <h2 id="writingpackages">Создание пакетов</h2>

Формат пакетов в Meteor официально не документирован и до версии 1.0 
изменится еще не раз. Но это не остановило таких людей, как вы, и они 
написали сотни сторонних пакетов, читая исходные коды официальных и делая все
по их подобию. Если вы решили создать собственный пакет, то вам придется 
провести небольное расследование и, для начала, вот вам несколько простых
советов:

* Пакет - это просто директория с находящимся в ней файлом `package.js`. 
  Примеры таких файлов можно найти в [директории `packages` исходного 
  кода Meteor](https://github.com/meteor/meteor/tree/master/packages/). До 
  выхода версии Meteor 1.0, формат и имя файла `package.js`, наверняка, сильно 
  изменятся, но его функции останутся в основном такими же, поэтому вам не 
  составит труда портировать его код.

* Пакет должен явно перечислить список всех его исходников, используя функцию 
  `api.add_files` и загружены они будут именно в том порядке, в котором 
  указаны. (В этом пакеты отличаются от приложений, для которых Meteor 
  сканирует директории в поисках исходников). Не забывайте указывать 
  используемые вами плагины для сборки (такие как `coffeescript` или, если 
  используете HTML-шаблоны, `templating`).

* Внешние переменные пакета (см. [Пространство имен](#namespacing)) 
  объявляются путем вызова функции `api.export` из обработчика `on_use`.

* У внешних переменных существует одна скрытая особенность - они не
  l-значения (lvalues). Вы не можете присвоить внешней переменной другое
  значение после того, как она уже была объявлена, т.е. если, например, вы
  объявляете внешнюю переменную `a = {name: 'alice'}`, то вы в любой момент
  можете изменить значение `a.name`, но если вы сразу после запуска приложения
  запишите в `a` совершенно другой объект, то пакеты, использующие `a` не
  увидят этих изменений.

* Пакеты могут использовать [npm-модули](https://npmjs.org/). Для
  перечисления необходимых вам модулей и их версий используйте функцию
  `Npm.depends` в файле `package.js`. Затем в коде вашего пакета загружайте
  необходимые модули при помощи `Npm.require`. Вам обязательно нужно
  указывать точные версии npm-модулей, т.к. Meteor стремится к стопроцентному
  воспроизведению вашего приложения при его пересборке. Это гарантирует, что
  все ваши коллеги всегда будут работать с одим и тем же кодом. За кулисами,
  Meteor использует команду `npm shrinkwrap`, чтобы дополнительно заморозить
  зависимости всех используемых в пакете npm-модулей.

* Всякий раз, когда ваш пакет изменяется, Meteor пересобирает его заного
  (скомпилирует не-Javascript файлы, получит все npm-зависимости, создаст
  обертки для поддержки пространств имен и т.д.). Собранный пакет кэшируется
  и будет пересобран только когда изменятся его исходники (отслеживается при
  помощи SHA1) или зависимости. Чтобы принудительно пересобрать пакет, вы
  можете воспользоваться недокументированной командой `meteor rebuild-all`,
  но такой ситуации у вас, по идее, быть не должно (но если она все-таки
  произошла, обязательно пришлите нам [отчет об
  ошибке](https://github.com/meteor/meteor/blob/devel/Contributing.md#filing-bug-reports)!).

* Плагины для сборки создаются при помощи
  `_transitional_registerBuildPlugin`. Этот API в данный момент находится в
  активной разработке. В качестве примера можете посмотреть пакет
  `coffeescript`. Плагины для сборки - это полноценные программы на Meteor, с
  собственным пространством имен, зависимостями, исходниками и
  npm-модулями. Старое API, использующее `register_extension`, удалено.

* Между пакетам можно создавать слабые зависимости. Если пакет A объявляет
  слабую зависимость от пакета B, то при добавление пакета A в приложение,
  пакет B в него добавлен не будет, но если он был в него включен напрямую
  разработчиком, либо другим пакетом, то он будет загружен перед пакетом A.
  Этот тип зависимости позволяет по возможности воспользоваться каким-либо
  другим пакетом, если он тоже добавлен в ваше приложение, либо
  расширить его функционал. Чтобы создать слабую зависимость, передайте
  объект `{weak: true}` в качестве третьего аргумента функции `api.use`.
  Если ваш пакет слабо зависит от какого-либо другого, то его внешние
  переменные вам недоступны. Таким образом, понять, добавлен ли он в
  приложение и получить доступ к его внешним переменным вы можете, используя
  объект `Package.foo` где `foo` - название данного пакета.

* Также вы можете создавать неупорядоченные зависимости, передавая в качестве
  аргумента `{unordered: true}`. Это полная противоположность слабой
  зависимости. Если A создает неупорядоченную зависимость от B, то добавление
  в приложение пакета A приводит к добавление в него и пакета B, но при этом
  B не обязан быть загружен перед A. Это иногда полезно для разрешения
  циклических зависимостей.

* Система сборки также поддерживает составные пакеты. Если пакет A включает в
  себя пакет B, то это означает, что подключивший пакет A также зависит и от
  пакета B. В частности, подключившему A становятся доступны внешние
  переменные пакета B. Делается это при помощи функции `api.imply` и может
  быть использовано для создания пакетов-контейнеров, таких как
  `standard-app-packages` (которые, по сути, служат для удобного объявления
  группы пакетов), или же для вынесения общего кода из нескольких пакетов,
  как в случае с `accounts-base`.

* Система сборки понимает идею нативного кода и обладает системой
  архитектурно-зависимых имен, необходимой для того, чтобы не использовать
  пакеты, предназначенные для одной архитектуры, в другой, несовместимой в ней.
  Например, если ваш пакет зависит от npm-модуля, в состав которого входит
  нативное расширение, то ваше собранное Meteor-приложение будет работать
  только на системах со схожей архитектурой, иначе оно будет портативное.

{{/markdown}}
</template>
