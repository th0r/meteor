<template name="concepts">

<h1 id="concepts">Концепции</h1>

Мы написали большое количество одностраничных приложений на JavaScript вручную.
Написание всего приложения на одном языке (JavaScript), используя один формат данных
(JSON) - это сказка. И все, что нам тогда было нужно для их написания - это Meteor.

{{> whatismeteor }}
{{> structure }}
{{> data }}
{{> reactivity }}
{{> livehtml }}
{{> templates }}
{{> packages_concept }}
{{> namespacing }}
{{> deploying }}
{{> packages_writing }}
</template>

<template name="whatismeteor">

{{#better_markdown}}

<h2 id="whatismeteor">Что такое Meteor?</h2>

Meteor - это две вещи:

* _Библиотека пакетов_: заранее написанные независимые модули, которые
могут вам понадобиться в вашем приложении.<br>
Ядро Meteor состоит примерно из дюжины таких пакетов, которые будут
использоваться в большинстве приложений (например пакет `webapp`, который
обрабатывает входящие HTTP-подключения, и `templating`, который позволяет
писать HTML-шаблоны, автоматически обновляемые при изменении данных).
Также существуют дополнительные пакеты, например `email`, который позволяет
вашему приложению посылать email-ы, или серия пакетов Meteor Accounts (`account-password`,
`accounts-facebook`, `accounts-ui` и другие) которые предоставляют полноценную
систему учетных записей для вашего приложения. И помимо этих "официальных" пакетов,
в [Atmosphere](https://atmosphere.meteor.com/) присутствуют сотни других, написанных
сообществом, и один из них, возможно, делает именно то, что вам необходимо.

* _Утилита командной строки_ `meteor`.<br>
`meteor` - это утилита для сборки, аналогичная `make`, `rake`, или 
без-интерфейсным частям Visual Studio. Она собирает воедино все исходники и
статику вашего приложения, выполняет все необходимые шаги сборки (такие, как
компилирование [CoffeeScript](http://coffeescript.org), минификация CSS,
сборка [npm](https://npmjs.org/)-модулей и генерация source maps), загружает 
все модули, используемые в вашем приложении и создает из него автономный 
пакет, готовый к использованию. В режиме разработки она делает все это "на 
лету", т.е. каждый раз, когда вы вносите какие-либо изменения в файл, вы
сразу же видите это в браузере. Она очень простая в использовании и к тому же
легко расширяемая: вы можете добавить поддержку дополнительных языков и 
компиляторов, просто добавив в ваше приложение дополнительные пакеты для сборки.

Основная идея пакетной системы Meteor состоит в том, что _все должно работать
одинакого как в браузере, так и на сервере_ (конечно, если это имеет смысл: 
браузеры не умеют посылать email-ы, а серверы - ловить события мышки). Вся 
наша экосистема была построена с нуля, чтобы обеспечить работоспособность 
данного подхода.

{{#note}}
Утилита `meteor` пока не умеет загружать пакеты из Atmosphere. Если же вы
хотите их использовать, то вам следует взглянуть на 
[Meteorite](http://oortcloud.github.io/meteorite/) - эта утилита поможет вам 
с загрузкой и управлением пакетами из Atmosphere.

В Meteor 1.0 утилита `meteor` будет полностью поддерживать Atmosphere.
{{/note}}

{{/better_markdown}}
</template>

<template name="structure">
{{#better_markdown}}

<h2 id="structuringyourapp">Создание структуры вашего приложения</h2>

Приложение на Meteor - это смесь клиентского JavaScript, который работает в
браузере, серверного JavaScript, который работает под управлением
[Node.js](http://nodejs.org/) и всех поддерживаемых форматов HTML, CSS и 
других статичных ресурсов. Meteor автоматизирует упаковку и передачу всех этих 
компонентов и позволяет вам иметь довольно гибкую структуру файлов в
директории вашего приложения.

Единственными статическими ресурсами со стороны сервера являются 
JavaScript-файлы и файлы из поддиректории `private`. Meteor собирает все 
JavaScript-файлы, кроме тех, которые находятся в поддиректориях `client`, 
`public` и `private`, и загружает их в экземпляр Node.js-сервера, используя 
волокна (fibers). Ваш серверный код в Meteor работает в режиме "один поток на
один запрос", а не в привычном для Node режиме асинхронных обратных вызовов 
(callbacks). Мы считаем, что линейная модель исполнения лучше подходит 
для типичного серверного кода приложения на Meteor.

Meteor собирает все файлы из поддиректории `private` и предоставляет доступ к
их содержимому при помощи [`Assets`](#assets) API. Поддиректория `private` 
предназначена для хранения любых файлов, которые должны быть доступны 
серверному коду, но недоступны клиентскому. Например, файлов с 
конфиденциальной информацией.

На клиенте статичных ресурсов побольше. Для него Meteor собирает все
JavaScript-файлы из директории вашего приложения за исключением тех,
которые находятся в поддиректориях `server`, `public` и `private`. Он 
минифицирует получившийся пакет и раздает его каждому клиенту. Таким образом вы
можете либо написать ваше приложение в одном JavaScript-файле, либо же
создать вложенное дерево с множеством отдельных файлов.

Некоторые JavaScript-библиотеки работают только если их поместить в 
поддиректорию `client/compatibility`. У данных файлов не меняется область 
действия переменных, т.е. каждая внешняя переменная, объявленная через `var`,
создает глобальную переменную. К тому же, эти файлы на клиенте выполняются 
самыми первыми.

Файлы, находящиеся вне директорий `client`, `server` и `tests`, загружаются 
как на клиентe, так и на серверe! Это самое место для объявления моделей и 
разных общих функций. У объекта Meteor есть свойства 
[`isClient`](#meteor_isclient) и [`isServer`](#meteor_isserver), используя 
которые вы можете определить, где сейчас выполняется ваш код - на клиенте, 
или на сервере. (Файлы из директорий `tests` никуда не загружаются.)

Любой конфиденциальный код, который не должен попасть на клиент (например, 
код, содержащий пароли или механизмы аутентификации), необходимо хранить в 
директории `server`.

CSS файлы из всех поддиректорий проекта, кроме `server`, `public` и 
`private`, также собираются в один пакет и отправляются на клиент.

В режиме разработки, JavaScript и CSS-файлы отсылаются на клиент не в виде 
пакета, а как индивидуальные файлы. Сделано это для того, чтобы облегчить 
отладку приложения.

HTML-файлы Meteor обрабатывает несколько иначе, чем остальные фреймворки. 
Meteor сканирует все HTML-файлы в поисках трех элементов верхнего
уровня: `<head>`, `<body>` и `<template>`. Все секции `head` и `body` 
объединяются и передаются на клиент при первоначальной загрузке страницы.

Секции `template` же преобразуются в JavaScript-функции и сохраняются в 
объекте `Template` - это очень удобный способ передачи HTML-шаблонов на 
клиент. Более подробно об этом можно узнать в разделе ["Шаблоны"](#templates).

И наконец, Meteor будет раздавать любые файлы, находящиеся в директории 
`public` точно так же, как это делают, например, Django или Rails. Там 
следует хранить изображения, `favicon.ico`, `robots.txt` и прочую статику.

Лучше всего стараться писать ваше приложение таким образом, чтобы оно не 
зависило он порядка загрузки файлов. Для этого можно использовать функцию 
[Meteor.startup](#meteor_startup), или помещать код, зависящий от порядка 
загрузки, в [пакеты](#usingpackages), которые позволяют явно указать не только 
порядок загрузки их частей, но и их зависимости от других пакетов. Несмотря 
на это бывают ситуации, когда порядок загрузки файлов важен. Для решения 
таких проблем существует несколько правил, по которым ваше приложение 
загружает JavaScript и CSS:

* Самыми первыми загружаются файлы из директории `lib`, находящейся в корне 
  вашего приложения.

* Самыми последними загружаются файлы с именем `main.*`.

* Файлы из поддиректорий загружаются раньше файлов, находящихся в 
  родительских директориях. Таким образом файлы из самой глубокой 
  поддиректории загружаются первыми (но после `lib`), а файлы из корня
  приложения - последними (но перед `main.*`).

* В рамках одной директории файлы загружаются в алфавитном порядке по их 
  названию.

Эти правила применяются по очереди, т.е. внутри `lib`, например, файлы
загружаются в алфавитном порядке, а файл `main.js`, находящийся в 
поддиректории, загружается раньше файла `main.js` из корня приложения.

{{/better_markdown}}
</template>

<template name="data">
{{#better_markdown}}

<h2 id="dataandsecurity">Данные и безопасность</h2>

Общаться с локальной базой данных в Meteor так же просто, как и писать 
клиентский код. Это простой, понятный и безопасный подход, который устраняет 
необходимость создавать индивидуальные конечные точки RPC, вручную кешировать
данные на клиенте, чтобы не ждать долгих ответов от сервера и аккуратно 
оповещать клиентов о том, что данные на сервере изменились.

Клиент и сервер в Meteor используют одинаковое API для работы с базой данных.
Таким образом, один и тот же код, например, валидаторы или 
вычисляемые свойства, обычно можно использовать в обоих местах. Но если у 
серверного кода есть прямой доступ к базе данных, то у клиент его *нет*.
И это отличие - основа модели безопасности данных в Metor.

{{#note}}
Каждое новое приложение по умолчанию использует пакеты `autopublish` и 
`insecure`, которые в сочетании друг с другом создают эффект присутствия у 
каждого клиента полного доступа к базе данных сервера на чтение и запись. Эти
пакеты бывают довольно удобны при разработке приложения, но, как
правило, не подходят для подакшена. Так что, просто удалите из, как только вы
будете готовы.
{{/note}}

Каждый клиент в Meteor содержит кэш базы данных и хранит его в памяти. 
Управление его содержимым происходит следующим образом: сервер *публикует* 
некоторые наборы JSON-документов, а клиент *подписывается* на них. Как только
документы из набора меняются, сервер обновляет (патчит) клиентский кеш.

В настощее время большиство приложений на Meteor в качестве базы данных 
используют MongoDB, потому что она поддерживается лучше всего, но на будущее 
запланирована поддержка и других баз данных. Для объявления Mongo-коллекций и
работы с ними используется класс
[`Meteor.Collection`](http://docs.meteor.com/#meteor_collection). Благодаря 
`minimongo` (эмулятору Mongo на клиенте), его можно использовать как на 
сервере, так и на клиенте.

    // создание коллекций
    // этот код должен быть объявлен как на сервере, так и на клиенте
    Rooms = new Meteor.Collection("rooms");
    Messages = new Meteor.Collection("messages");
    Parties = new Meteor.Collection("parties");

    // сервер: наполнение коллекций несколькими начальными документами
    Rooms.insert({name: "Conference Room A"});
    var myRooms = Rooms.find({}).fetch();
    Messages.insert({text: "Hello world", room: myRooms[0]._id});
    Parties.insert({name: "Super Bowl Party"});

Каждый набор документов определяется функцией публикации на сервере. Она 
вызывается каждый раз, когда клиент подписывается на этот набор. Данные для 
него могут браться откуда угодно, но самый распространенный вариант - это 
публиковать результаты запроса к базе данных.

    // сервер: опубликовать информацию о всех чатах
    Meteor.publish("all-rooms", function () {
      return Rooms.find(); // everything
    });

    // сервер: опубликовать все сообщения из конкретного чата
    Meteor.publish("messages", function (roomId) {
      check(roomId, String);
      return Messages.find({room: roomId});
    });

    // сервер: опубликовать набор групп, которые может видеть залогиненный
    пользователь
    Meteor.publish("parties", function () {
      return Parties.find({$or: [{"public": true},
                                 {invited: this.userId},
                                 {owner: this.userId}]});
    });

Функции публикации могут отдавать разным клиентам разные результаты. В 
предыдущем примере, залогиненный пользователь может видеть только публичные 
группы, созданные им группы и группы, в которые его пригласили.

Как только клиент подписался на публикацию, он использует свой кэш в качестве 
быстрой локальной базы данных, что значительно упрощает клиентский код. Для 
чтения данных оттуда не нужны накладные обращения к серверу. К тому же, 
результаты запросов к локальной базе данных всегда ограничены набором
документов, которые сервер решил опубликовать для данного клиента.

    // клиент: начать подписку на группы
    Meteor.subscribe("parties");

    // клиент: получить массив групп, доступных данному пользователю
    return Parties.find().fetch(); // синхронно!

Продвинутый клиентский код может подписываться на публикации и отписываться от
них, тем самым контролируя объем данных, хранящихся в локальном кэше, и 
управляя сетевым трафиком. Когда подписка прекращена, все ее документы 
удаляются из кэша, если только они не входят в состав какой-либо другой
активной подписки.

Когда клиент *изменяет* один или несколько документов, он посылает сообщение 
серверу с запросом на это изменение. Сервер проверяет данное изменение, 
используя набор разрешающих и запрещающих правил, которые представляют собой 
обычные JavaScript функции. Если все правила пройдены успешно, то сервер 
разрешает данное изменение.

    // сервер: не разрешать клиенту добавлять группу
    Parties.allow({
      insert: function (userId, party) {
        return false;
      }
    });

    // клиент: группа не будет добавлена
    var party = { ... };
    Parties.insert(party);

Если сервер разрешает изменение, он вносит его в базу данных и автоматически
рассылает его всем остальным клиентам, подписанным на измененные документы. 
Если же не разрешает, то база данных на сервере остается нетронутой и никто 
из остальных клиентов этого изменения не видит.

Однако, в Meteor есть одна уловка. Когда клиент хочет записать что-то в базу 
данных и запрашивает разрешение на это у сервера, он не ждет от него ответа, а 
сразу же вносит это изменение в свой локальный кэш. Это означает, что 
интерфейс тут же перерисуется и если сервер примет данное изменение (а в 
правильно работающем клиенте это должно происходить почти всегда), то он 
будет уже в актуальном состоянии. Если же сервер отклонит это изменение, то 
Meteor откатит состояние локального кэша до исходного.

В итоге, все эти методы и обеспечивают компенсацию задержек: клиенты хранят 
локально свежую копию необходимых им данных и им не нужно ждать ответа от 
сервера. Таким образом, когда клиенту нужно изменить какие либо данные, он может 
сделать это локально, не дожидаясь подтверждения сервера, но в то же время 
оставляя за ним решающее слово касательно возможности этих изменений.

{{#note}}
Текущая версия Meteor поддерживает MongoDB - популярную
документо-ориентированную базу данных, а примеры в этом разделе используют 
[MongoDB API](http://www.mongodb.org/display/DOCS/Manual). Поддержка других 
баз данных появится в будущих версиях.
{{/note}}

<h3 id="dataandsecurity-authentication">Аутентификация и учетные записи 
пользователей</h3>

Meteor включает в себя передовую систему аутентификации - [Meteor
Accounts](#accounts_api). Она предоставляет возможность логина с 
использованием пароля, защищенного по протоколу [Secure Remote 
Password](http://en.wikipedia.org/wiki/Secure_Remote_Password_protocol), а 
также интеграцию с внешними сервисами, включая Facebook, GitHub,
Google, Meetup, Twitter и Weibo. Meteor Accounts создает коллекцию 
[`Meteor.users`](#meteor_users), где разработчики приложения могут хранить 
разнообразные данные о пользователях.

Meteor также содержит готовые формы для таких частых действий, как логин, 
регистрация, смена и сброс пароля. Пакет с этими формами называется [Accounts
UI](#accountsui). Чтобы добавить его в ваше приложение, нужно написать всего
одну строчку кода. В состав этого пакета входит даже визард для настройки 
внешних сервисов, поддержку которых вы хотите добавить в ваше приложение.

<h3 id="dataandsecurity-validation">Проверка входных данных</h3>

Meteor позволяет вашим методам и публикациям принимать параметры любого типа,
поддерживаемого форматом [JSON](http://json.org/). (На самом 
деле сетевой протокол Meteor поддерживает [EJSON](#ejson) - расширение JSON, 
которое также поддерживает другие базовые типы данных, такие как даты и 
двоичные буферы). Динамическое типизирование, используемое в JavaScript, 
означает, что вам не нужно указывать тип каждой переменной в вашем 
приложении, но как правило бывает очень удобно удостовериться, что аргументы,
переданные пользователем в ваши методы и публикации, имеют именно тот тип, 
который вы ожидаете.

Meteor включает в себя [маленькую библиотеку](#match) для проверки типа и 
структуры переменных. Просто начинайте ваши функции с таких выражений, как 
`check(username, String)`, или `check(office, {building: String, room: 
Number})`. Функция `check` выдаст ошибку, если ее аргумент не будет нужного 
вам типа.

Meteor также предоставляет легкий способ убедиться в том, что все ваши методы 
и публикации проверяют все свои параметры. Просто выполните команду 
<code>meteor add [audit-argument-checks](#auditargumentchecks)</code> и любой
метод или публикация, которая не проверяет свои аргументы, используя функцию 
`check`, завершится с исключением.

{{/better_markdown}}
</template>

<template name="reactivity">
{{#better_markdown}}

<h2 id="reactivity">Реактивность</h2>

Meteor реализует концепцию реактивного программирования ([reactive 
programming](http://en.wikipedia.org/wiki/Reactive_programming)). Это 
означает, что вы можете писать свой код в простом императивном стиле и 
результат будет автоматически пересчитан как только изменятся данные, от 
которых ваш код зависит.

    Deps.autorun(function () {
      Meteor.subscribe("messages", Session.get("currentRoomId"));
    });

Этот код, взятый из примера создания чат-клиента, подписывается на данные, 
используя значение переменной сессии `currentRoomId`. Если значение выражения
`Session.get("currentRoomId")` по каким-либо причинам изменится, функция 
автоматически перевыполнится и подпишется на новый набор документов, 
предварительно отписавшись от предыдущего.

Это автоматическое перевыполнение достигается благодаря совместному 
использованию `Session` и `Deps.autorun`. `Deps.autorun` выполняет 
произвольное "реактивное вычисление", отслеживая все данные, от которого оно 
зависит, и перезапускает его в случае необходимости. С другой стороны, 
источники данных, такие как `Session`, запоминают реактивное вычисление, из 
которого они вызываются, и запрошенные у них данные, чтобы послать вычислению
инвалидирующий сигнал как только эти данные изменятся.

Этот простой паттерн (реактивые вычисления + реактивные источники данных) 
имеет широкое применение. В примере выше, программист избавляется от 
необходимости писать код для своевременной отписки от публикации и
переподписки на нее. В целом, Meteor может устранить целые классы кода, 
предназначенного для распространения данных, которые иначе могли бы засорить 
ваше приложение ненадежной логикой.

Эти функции в Meteor выполняют ваш код в реактивном контексте:

* [Шаблоны](#templates)
* [`Meteor.render`](#meteor_render) и [`Meteor.renderList`](#meteor_renderlist)
* [`Deps.autorun`](#deps_autorun)

А вот список реактивных источников данных:

* Переменные сессии ([`Session`](#session))
* Запросы к базе данных через [коллекции](#find)
* [`Meteor.status`](#meteor_status)
* Метод `ready()` у [хэндлера подписки](#meteor_subscribe)
* [`Meteor.user`](#meteor_user)
* [`Meteor.userId`](#meteor_userid)
* [`Meteor.loggingIn`](#meteor_loggingin)

К тому же, если следующие функции, возвращающие объект с методом `stop`, 
вызываются в реактивном контексте, то они останавливаются, когда реактивное 
вычисление перезапускается или останавливается:

* [`Deps.autorun`](#deps_autorun) (вложенные вызовы)
* [`Meteor.subscribe`](#meteor_subscribe)
* [`observe()`](#observe) и [`observeChanges()`](#observe_changes) у курсоров

В Meteor реактивность 
[реализована](https://github.com/meteor/meteor/blob/master/packages/deps/deps.js)
в пакете [`Deps`](#deps), который довольно маленький и простой. С его помощью
вы можете самостоятельно создавать новые реактивные источники данных.

{{/better_markdown}}
</template>

<template name="livehtml">
{{#better_markdown}}

<h2 id="livehtml">Живой HTML</h2>

HTML-шаблоны занимают важнейшее место в любом веб-приложении. В Meteor 
используется фирменная технология "живых страниц", которая позволяет вам
_реактивно_ рендерить ваши шаблоны. Это означает, что они будут обновляться
автоматически, как только изменятся данные, необходимые для их отрисовки.

Эта функция работает с любым HTML-шаблонизатором и даже с HTML, созданным 
вручную из JavaScript:

    var fragment = Meteor.render(
      function () {
        var name = Session.get("name") || "Anonymous";
        return "<div>Hello, " + name + "</div>";
      });
    document.body.appendChild(fragment);

    Session.set("name", "Bob"); // страница обновится автоматически!

[`Meteor.render`](#meteor_render) принимает функцию рендеринга, которая должна 
возвратить HTML в виде строки. Сама же она возвращает автоматически 
обновляемый фрагмент документа - `DocumentFragment`. Как только изменяются 
данные, используемые в функции рендеринга, она перезапускается и DOM-ноды, 
находящиеся во фрагменте документа, обновляются в не зависимости от того, в
какую часть страницы они были вставлены. Все происходит полностью 
автоматически. Чтобы понять, от каких данных зависит функция рендеринга, 
[`Meteor.render`](#meteor_render) использует [реактивный контекст](#reactivity).

Однака, в большинстве случаев вы не будете вызывать эти функции явно - вы 
просто будете пользоваться вашим любимым шаблонизатором, например Handlebars
или Jade. Функции `render` и `renderList` предназначены для людей, создающих 
новые шаблонизаторы.

Meteor, как правило, собирает все необходимые в данный момент обновления и 
применяет их только после того, как ваш код закончит работу. Таким образом, 
вы можете быть уверены, что DOM не поменяется прямо у вас под ногами. Но 
иногда именно это вам и нужно. Например, если вы только что добавили запись в
базу данных и хотите принудительно обновить DOM, чтобы отыскать в нем новые 
элементы при помощи jQuery или какой-либо другой подобной библиотеки. В таком
случае просто выполните [`Deps.flush`](#deps_flush), чтобы привести ваш DOM в
актульное состояние.

Как только "живые" DOM-элементы убираются с экрана, они автоматически 
чистятся &mdash; их колбэки удаляются, все связанные с ними запросы к базе 
данных останавливаются и они перестают обновляться. Поэтому вам никогда не 
придется волноваться из-за [шаблонов-зомби (zombie 
templates)](http://lostechies.com/derickbailey/2011/09/15/zombies-run-managing-page-transitions-in-backbone-apps/),
которые являются настоящей напастью при написании логики обновления страницы 
вручную. Чтобы защитить ваши элементы от очистки, просто удостоверьтесь, что 
они будут на экране непосредственно перед тем, как ваш код вернется в цикл
обработки событий (event loop), или перед вызовом [`Deps.flush`](#deps_flush).

Еще одна острая проблема в приложениях, написанных вручную - это сохранение 
элементов. Допустим, пользователь вводит текст в `<input>`, и тут область 
сайта, в которой находится этот элемент, перерисовывается. Юзер может быть 
несколько обескуражен, когда на месте старого инпута появится новый - без фокуса
на нем и без только что набранного текста.

Это еще одна проблема, которую за вас решает Meteor. Вы можете указать 
элементы, которые хотите сохранить во время перерисовки, используя свойство 
шаблона [`preserve`](#template_preserve). Meteor сохранит эти элементы, даже
если содержащий их шаблон перерисуется, но в то же время будет исправно
обновлять их атрибуты и детей.

{{/better_markdown}}
</template>

<template name="templates">
{{#better_markdown}}

<h2 id="templates">Шаблоны</h2>

Meteor позволяет с легкостью использовать ваш любимый шаблонизатор, например,
Handlebars или Jade, вместе с фирменной технологией "живых страниц". Просто
пишите шаблоны как обычно, а Meteor позаботится о том, чтобы они обновлялись 
в реальном времени.

Чтобы воспользоваться этой возможностью, создайте в вашем проекте файл с
расширением `.html`. В файле создайте тэг `<template>`, положите в него ваш 
шаблон и задайте ему имя в атрибуте `name`. Meteor скомпилирует ваш шаблон и
отправит его на клиент, где он будет доступен в качестве функции глобаного 
объекта `Template`.

{{#note}}
Единственный шаблонизатор, доступный на сегодняшний день для использования в
Meteor - это Handlebars. Сообщите нам, какие еще шаблонизаторы вы бы хотели 
использовать в Meteor. А пока, посмотрите [документацию к 
Handlebars](http://www.handlebarsjs.com/) и [расширение Handlebars в 
Meteor](https://github.com/meteor/meteor/wiki/Handlebars).
{{/note}}

Для того, чтобы отрендерить шаблон с именем `hello`, нужно вызвать функцию 
`Template.hello`, передав в нее все необходимые для шаблона данные:

    <!-- in myapp.html -->
    <template name="hello">
      <div class="greeting">Hello there, {{dstache}}first}} {{dstache}}last}}!</div>
    </{{! }}template>

    // в консоле браузера
    > Template.hello({first: "Alyssa", last: "Hacker"});
     => "<div class="greeting">Hello there, Alyssa Hacker!</div>"

Результатом является строка. Чтобы превратить этот шаблон в [`Живой 
HTML`](#livehtml) и получить самообновляющиеся DOM-элементы, используйте 
[`Meteor.render`](#meteor_render):

    Meteor.render(function () {
      return Template.hello({first: "Alyssa", last: "Hacker"});
    })
      => самообновляющиеся DOM-элементы

Самый простой способ передать данные в шаблон - это объявить для него 
функции-хэлперы. Просто добавьте их, как методы объекта `Template.[название 
шаблона]`. Например, в этом шаблоне:

    <template name="players">
      {{dstache}}#each topScorers}}
        <div>{{dstache}}name}}</div>
      {{dstache}}/each}}
    </{{! }}template>

вместо того, чтобы передавать `topScorers` в качестве данных при вызове 
функции шаблона, мы могли бы объявить функцию в объекте `Template.players`:

    Template.players.topScorers = function () {
      return Users.find({score: {$gt: 100}}, {sort: {score: -1}});
    };

В этом случае информация берется из запроса к базе данных. Когда в `#each` 
передается курсор, этот хэлпер использует все доступные средства для 
эффективного добавления и перемещения DOM-элементов при изменении набора 
документов в запросе.

Хэлперы могут принимать аргументы, а в `this` они получают текущие данные для 
шаблона:

    // в JavaScript-файле
    Template.players.leagueIs = function (league) {
      return this.league === league;
    };

    <!-- в HTML-файле -->
    <template name="players">
      {{dstache}}#each topScorers}}
        {{dstache}}#if leagueIs "junior"}}
          <div>Junior: {{dstache}}name}}</div>
        {{dstache}}/if}}
        {{dstache}}#if leagueIs "senior"}}
          <div>Senior: {{dstache}}name}}</div>
        {{dstache}}/if}}
      {{dstache}}/each}}
    </{{! }}template>

{{#note}}
Примечание по Handlebars: Использование таких конструкций, как 
`{{dstache}}#if leagueIs "junior"}}` возможно благодаря расширению Meteor, 
которое позволяет использовать хэлпер в блок-хэлпере. (По сути, и 
`if` и `leagueIs` здесь - хелперы, и стандартный Handlebars не вызвал бы 
здесь хэлпер `leagueIs`.)
{{/note}}

Хэлперы также можно использовать для передачи неизменной информации.

    // Прекрасно работает с {{dstache}}#each sections}}
    Template.report.sections = ["Situation", "Complication", "Resolution"];

И наконец, вы можете указать таблицу обработчиков событий, используя свойство
`events` функции шаблона. Формат этой таблицы указан в разделе [Карты
событий](#eventmaps). В обработчике события, `this` будет указывать на 
контекст данных того элемента, который это событие вызвал.

    <!-- myapp.html -->
    <template name="scores">
      {{dstache}}#each player}}
        {{dstache}}> playerScore}}
      {{dstache}}/each}}
    </{{! }}template>

    <template name="playerScore">
      <div>{{dstache}}name}}: {{dstache}}score}}
        <span class="givePoints">Give points</span>
      </div>
    </{{! }}template>

    <!-- myapp.js -->
    Template.playerScore.events({
      'click .givePoints': function () {
        Users.update(this._id, {$inc: {score: 2}});
      }
    });

Подводя итог всему сказанному, вот пример того, как вы можете передавать 
данные в ваши шаблоны, чтобы они автоматически обновлялись при их изменении. 
Дополнительную информацию можно найти в разделе [Живой HTML](#livehtml).

    <!-- в myapp.html -->
    <template name="forecast">
      <div>It'll be {{dstache}}prediction}} tonight</div>
    </{{! }}template>

    <!-- в myapp.js -->
    // JavaScript: реактивный хэлпер
    Template.forecast.prediction = function () {
      return Session.get("weather");
    };

    <!-- в консоле браузера -->
    > Session.set("weather", "cloudy");
    > document.body.appendChild(Meteor.render(Template.forecast));
    На странице:  <div>It'll be cloudy tonight</div>

    > Session.set("weather", "cool and dry");
    На странице:  <div>It'll be cool and dry tonight</div>

{{/better_markdown}}
</template>

<template name="packages_concept">
{{#better_markdown}}

  <h2 id="usingpackages">Работа с пакетами</h2>

Весь функционал, о котором вы читали до сих пор, реализован в виде 
стандартных Meteor-пакетов. Это возможно благодаря тому, что Meteor обладает 
необычано мощными системами сборки и управления пакетами. Одни и те же пакеты
могут работать как в браузере, так и на сервере, а также могут содержать 
плагины для расширения возможностей системы сборки, например `coffeescript`
(компиляция [CoffeeScript](http://coffeescript.org)) или `templating` 
(компиляция HTML-шаблонов).

Вы можете посмотреть список доступных пакетов с помошью команды [`meteor 
list`](#meteorlist), добавлять пакеты в ваш проект с помошью [`meteor 
add`](#meteoradd), и удалять их из проекта с помошью [`meteor 
remove`](#meteorremove).

По умолчанию, все новые приложения используют пакет `standard-app-packages`. 
Он включает в себя основные пакеты, составляющие ядро Meteor, и необходимые в
большинстве веб-приложений. Для простоты, они не показываются в списке при
использовании команды `meteor list`, но вы можете узнать их состав, заглянув в
[исходники пакета `standard-app-packages`](https://github.com/meteor/meteor/blob/master/packages/standard-app-packages/package.js) 
(так как Meteor еще не достиг версии 1.0, состав этого пакета может меняться 
от версии к версии). Если же для вашего приложения не нужны все базовые 
пакеты из `standard-app-packages`, то просто удалите его и добавьте из него
только нужные.

Команды `meteor list`, `meteor add` и `meteor remove` работают не только с 
официальными пакетами Meteor, но и с пакетами, находящимися в директории 
`packages` в корне вашего приложения. В нее вы и должны распаковывать все 
неофициальные пакеты, скачанные из Atmosphere (неофициальная утилита 
[Meteorite](http://oortcloud.github.io/meteorite/) значительно упрощает этот 
процесс). Также, для удобства, вы можете разбить ваше приложение на пакеты, 
если только вас не смущает тот факт, что формат пакетов в Meteor еще не 
документирован и наверняка сильно изменится до версии 1.0. Подробнее об этом 
можно почитать в разделе [Написание Пакетов](#writingpackages).

{{/better_markdown}}
</template>


<template name="namespacing">
{{#better_markdown}}

  <h2 id="namespacing">Namespacing</h2>

Meteor's namespacing support makes it easy to write large applications
in JavaScript. Each package that you use in your app exists in its own
separate namespace, meaning that it sees only its own global variables
and any variables provided by the packages that it specifically
uses. Here's how it works.

When you declare a top-level variable, you have a choice. You can make
the variable File Scope or Package Scope.

    // File Scope. This variable will be visible only inside this
    // one file. Other files in this app or package won't see it.
    var alicePerson = {name: "alice"};

    // Package Scope. This variable is visible to every file inside
    // of this package or app. The difference is that 'var' is
    // omitted.
    bobPerson = {name: "bob"};

Notice that this is just the normal JavaScript syntax for declaring a
variable that is local or global. Meteor scans your source code for
global variable assignments and generates a wrapper that makes sure
that your globals don't escape their appropriate namespace.

In addition to File Scope and Package Scope, there are also
Exports. An export is a variable that a package makes available to you
when you use it. For example, the `email` package exports the `Email`
variable. If your app uses the `email` package (and _only_ if it uses
the `email` package!) then your app can see `Email` and you can call
`Email.send`. Most packages have only one export, but some packages
might have two or three (for example, a package that provides several
classes that work together).

You see only the exports of the packages that you use directly. If you
use package A, and package A uses package B, then you only see package
A's exports. Package B's exports don't "leak" into your namespace just
because you used package A. This keeps each namespace nice and
tidy. Each app or package only sees their own globals plus the APIs of
the packages that they specifically asked for.

When debugging your app, your browser's JavaScript console behaves as
if it were attached to your app's namespace. You see your app's
globals and the exports of the packages that your app uses
directly. You don't see the variables from inside those packages, and
you don't see the exports of your transitive dependencies (packages
that aren't used directly by your app, but that are used by packages
that are used by your app).

If you want to look inside packages from inside your in-browser
debugger, you've got two options:

* Set a breakpoint inside package code. While stopped on that
  breakpoint, the console will be in the package's namespace. You'll
  see the package's package-scope variables, imports, and also any
  file-scope variables for the file you're stopped in.

* If a package `foo` is included in your app, regardless of whether
  your app uses it directly, its exports are available in
  `Package.foo`. For example, if the `email` package is loaded, then
  you can access `Package.email.Email.send` even from namespaces that
  don't use the `email` package directly.

When declaring functions, keep in mind that `function x () {}` is just
shorthard for `var x = function () {}` in JavaScript. Consider these
examples:

    // This is the same as 'var x = function () ...'. So x() is
    // file-scope and can be called only from within this one file.
    function x () { ... }

    // No 'var', so x() is package-scope and can be called from
    // any file inside this app or package.
    x = function () { ... }

{{#note}}
Technically speaking, globals in an app (as opposed to in a package)
are actually true globals. They can't be captured in a scope that is
private to the app code, because that would mean that they wouldn't be
visible in the console during debugging! This means that app globals
actually end up being visible in packages. That should never be a
problem for properly written package code (since the app globals will
still be properly shadowed by declarations in the packages). You
certainly shouldn't depend on this quirk, and in the future Meteor may
check for it and throw an error if you do.
{{/note}}

{{/better_markdown}}
</template>


<template name="deploying">
{{#better_markdown}}

<h2 id="deploying">Deploying</h2>

Meteor is a full application server.  We include everything you need
to deploy your application on the internet: you just provide the JavaScript,
HTML, and CSS.

<h3 class="nosection">Running on Meteor's infrastructure</h3>

The easiest way to deploy your application is to use `meteor
deploy`.  We provide it because it's what, personally, we've always
wanted: an easy way to take an app idea, flesh it out over a weekend,
and put it out there for the world to use, with nothing getting in the
way of creativity.

    $ meteor deploy myapp.meteor.com

Your application is now available at myapp.meteor.com.  If
this is the first time deploying to this hostname, Meteor creates a
fresh empty database for your application.  If you want to deploy an
update, Meteor will preserve the existing data and just refresh the
code.

You can also deploy to your own domain.  Just set up the hostname you
want to use as a CNAME to `origin.meteor.com`,
then deploy to that name.

    $ meteor deploy www.myapp.com

We provide this as a free service so you can try Meteor.  It is also
helpful for quickly putting up internal betas, demos, and so on.

<h3 class="nosection">Running on your own infrastructure</h3>

You can also run your application on your own infrastructure, or any
other hosting provider like Heroku.

To get started, run

    $ meteor bundle myapp.tgz

This command will generate a fully-contained Node.js application in the form of
a tarball.  To run this application, you need to provide Node.js 0.8 and a
MongoDB server.  (The current release of Meteor has been tested with Node
0.8.24.) You can then run the application by invoking node, specifying the HTTP
port for the application to listen on, and the MongoDB endpoint.  If you don't
already have a MongoDB server, we can recommend our friends at
[MongoHQ](http://mongohq.com).

    $ PORT=3000 MONGO_URL=mongodb://localhost:27017/myapp node bundle/main.js

Other packages may require other environment variables (for example, the `email`
package requires a `MAIL_URL` environment variable).

{{#warning}}
For now, bundles will only run on the platform that the bundle was
created on.  To run on a different platform, you'll need to rebuild
the native packages included in the bundle.  To do that, make sure you
have `npm` available, and run the following:

    $ cd bundle/programs/server/node_modules
    $ rm -r fibers
    $ npm install fibers@1.0.1
{{/warning}}

{{/better_markdown}}
</template>


<template name="packages_writing">
{{#better_markdown}}

  <h2 id="writingpackages">Writing packages</h2>

The Meteor package format isn't officially documented and will change
before Meteor 1.0. But that hasn't stopped people like you from
creating hundreds of packages by reading the source code of existing
packages and following the model. If you do decide to create your own
packages, you will have to do some detective work, but here are some
quick tips:

* A package is simply a directory with a `package.js` file in it. Look in the
  [`packages` directory of the Meteor source
  tree](https://github.com/meteor/meteor/tree/master/packages/) for example
  `package.js` files. The format and name of the `package.js` file will change
  significantly before Meteor 1.0, but the functionality will be basically the
  same even though the syntax is different, so it will be easy to port your
  code.

* Packages explicitly list all of their source files using `api.add_files`, and
  the files are loaded exactly in the order specified. (This is different from
  apps, where Meteor scans a directory tree to find the source files.)  Don't
  forget to include any build plugin packages (such as `coffeescript` or, if
  using HTML templates, `templating`) that you require.

* Exporting a symbol from your package (see
  [Namespacing](#namespacing)) is accomplished with an `api.export` call
  from inside your `on_use` handler.

* An esoteric point about exports: they are not lvalues. You can't set
  an exported variable to a new value after exporting it. If you
  export `a = {name: 'alice'}` then you can change `a.name` anytime
  you want, but if after startup you set `a` to a whole new object
  then the packages that import `a` won't see the change. Since your
  exports are most always objects or functions, this is hardly ever an
  issue.

* Packages can use [npm modules](https://npmjs.org/). Use `Npm.depends` in your
  `package.js` to list the npm modules that you need and the specific
  versions that you want to use. Then use `Npm.require` inside your
  package to pull in the modules when you need them. Meteor strives to
  have 100% repeatable builds so that everyone on your team is always
  running the same code, and that's why you must explicitly lock your
  npm dependencies to specific versions. Behind the scenes, Meteor
  will use `npm shrinkwrap` to also lock down the versions of the
  transitive dependencies of all of the npm modules that you use.

* Whenever your package changes, Meteor will rebuild it (compiling
  non-JavaScript source files, fetching npm dependencies, constructing
  namespace wrappers, and so on). The built package will be cached and
  rebuilt only when a source file changes (tracked by SHA1) or when
  other dependencies such as build plugins change. To force a rebuild
  you can use the undocumented command `meteor rebuild-all`, but this
  should never be necessary (if it is, please send a
  [bug report](https://github.com/meteor/meteor/blob/devel/Contributing.md#filing-bug-reports)!).

* Build plugins are created with `_transitional_registerBuildPlugin`,
  an API that is very much in flux. See the `coffeescript` package for
  an example. Build plugins are fully-fledged Meteor programs in their
  own right and have their own namespace, package dependencies, source
  files and npm requirements. The old `register_extension` API is
  deprecated and should not be used as it will prevent your package
  from being cached, slowing down builds.

* It is possible to create weak dependencies between packages. If
  package A has a weak dependency on package B, it means that
  including A in an app does not force B to be included too &mdash;
  but, if B _is_ included, say by the app developer or by another
  package, then B will load before A. You can use this to make
  packages that optionally integrate with or enhance other packages if
  those packages are present. To create a weak dependency, pass
  `{weak: true}` as the third argument to `api.use`. When you weakly
  depend on a package you don't see its exports. You can detect if
  the possibly-present weakly-depended-on package is there by seeing
  if `Package.foo` exists, and get its exports from the same place.

* It is also possible to create unordered dependencies by passing
  `{unordered: true}`. An unordered dependency is the exact opposite
  of a weak dependency. If A has an unordered dependency on B, then
  including A forces B to be included as well, but doesn't require B
  to load before A. This is occasionally useful for resolving circular
  dependencies.

* The build system also supports package implication. If package A
  implies package B, then it means that when someone depends on
  package A, it's as if they also depended on package B as well. In
  particular, they get B's exports. This is done with `api.imply` and
  can be used to create umbrella packages such as
  `standard-app-packages` that are a shortcut for pulling in a set of
  packages, or it can be helpful in factoring common code out of a set
  of packages as with `accounts-base`.

* The build system understands the idea of native code and has a
  system of architecture names to ensure that packages that are
  specific to one architecture aren't run on the wrong
  architecture. For example, if you include an npm module that has a
  native extension, your built Meteor package will be specific to your
  machine architecture, but if not your built Meteor package will be
  portable.

{{/better_markdown}}
</template>
